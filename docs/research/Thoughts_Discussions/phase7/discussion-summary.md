# 議論まとめ：ドメイン特化型動的UI生成の設計パラダイムと評価設計

## 1. 研究の位置づけ

### 1.1 研究の主題と貢献の優先順位

| 優先度 | 貢献 | 説明 |
|-------|------|------|
| 1 | **設計パラダイム** | ドメイン特化型動的UIシステムにおいて「何を固定し、何を動的にすべきか」の判断基準 |
| 2 | **Widget-to-Widget Reactivity** | 設計パラダイムを実現するための核心的手法。「固定UIで十分」への反論 |
| 3 | **トークン削減** | ドメイン特化の副次的効果 |
| 4 | **思考整理アプリでの実証** | 設計パラダイムの検証フィールド。アプリのUX自体は主題ではない |

### 1.2 Jellyとの差別化

| 観点 | Jelly | 本研究 |
|------|-------|--------|
| 適用範囲 | General（何でもコンシェルジュ） | Domain-Specific（思考整理特化） |
| UI部品 | Atom（原子部品から組み上げ） | Widget（事前定義された複合部品） |
| 連動単位 | Item-to-Item | Widget-to-Widget |
| ユーザー負担 | プロンプトを継続的に入力 | 初回入力のみ |

**最も強調すべき差別化：** General → Domain-Specific という視座の転換。その中でWidget-to-Widget Reactivityが重要な貢献。

---

## 2. 動的UI度ステージ

### 2.1 6段階の定義（Stage 0-5）

| Stage | 動的要素 | UI部品 | DSLシステムの必要性 |
|-------|---------|--------|-------------------|
| 0 | なし | 固定UI | 不要 |
| 1 | コンテンツ（アルゴリズミック） | 固定UI | 不要 |
| 2 | コンテンツ（LLM） | 固定UI | 不要 |
| 3 | Widget選択 + コンテンツカスタマイズ | Widget | **不要（オーバーエンジニアリング）** |
| **4** | **Widget間インタラクション定義** | **Widget** | **必要（本研究が採用）** |
| 5 | Widget構造自体（Atomから構築） | Atom | 必要だがUX品質担保が困難 |

### 2.2 本研究がStage 4を採用する理由

#### Stage 3を採用しない理由（否定的に記述）

**論点：Stage 3はオーバーエンジニアリングである**

1. Stage 3の定義：「LLMがWidgetを選択し、コンテンツをカスタマイズする」
2. Stage 2（固定UI + LLMコンテンツ生成）との差分が不明瞭
3. Widget選択はJSON出力で十分実現可能
4. コンテンツカスタマイズも各Widgetにデータを渡すだけ
5. **結論：** Stage 3のためにDSLベースの動的UI生成システムを導入する価値がない

#### Stage 4を採用する理由（肯定的に記述）

**論点：Stage 4でDSLシステムの価値が正当化される**

1. Stage 4の定義：「LLMがWidget間のインタラクション（連動ルール）を動的に定義する」
2. Stage 3との決定的な違い：**「見た目」だけでなく「動作」をLLMが生成する**
3. 連動パターンは文脈依存であり、事前に全パターンを定義することは非現実的
4. **結論：** ここでDSLシステムを導入する価値がある

#### Stage 5を採用しない理由

1. Atomから組み上げるとLLMが毎回最適なUXを生成できるとは限らない
2. ドメイン特化ならWidgetを事前定義してUX品質を担保できる
3. トークンコストも増大する

### 2.3 Stage 4の具体例（概念的説明）

#### 例1：優先度評価UI

**Stage 3の場合：**
> LLMは「優先度スライダーを使う」「項目はA, B, Cである」という選択とコンテンツを生成する。これは固定UIにデータを渡すだけで実現可能である。

**Stage 4の場合：**
> LLMはさらに「ユーザーが緊急度・重要度・工数のスライダーを操作すると、その重み付けに基づいてランキングがリアルタイムに更新される」という連動ルール自体を生成する。どの軸をどう組み合わせてランキングに反映するかは、ユーザーの悩みの文脈によって異なるため、事前に全パターンを定義することは非現実的である。

#### 例2：依存関係マッピング

**Stage 3の場合：**
> LLMは「依存関係図を使う」「ノードは仕事・健康・家族である」と生成する。

**Stage 4の場合：**
> LLMは「ユーザーがノード間を接続すると、最も影響が大きい経路（クリティカルパス）が右側に自動でハイライトされる」という連動ルールを生成する。何をクリティカルパスとみなすかは、ユーザーの問題構造によって異なる。

### 2.4 独立軸として扱う要素

| 軸 | 本研究の選択 | 理由 |
|---|-------------|------|
| スタイル/見た目 | 固定 | エンゲージメント向上は別目的の研究（Future Work） |
| 配置/レイアウト | 半固定 | 思考整理では視線誘導より内容が重要 |

---

## 3. 設計パラダイム：何を固定し、何を動的にするか

### 3.1 判断結果

| 要素 | 固定/動的 | 理由 |
|------|----------|------|
| Widget種類 | 固定 | UX品質担保、トークン削減 |
| フロー構造 | 半固定 | ドメイン知識（発散→整理→収束） |
| Widget選択 | 動的 | ユーザーの悩みに適応 |
| Widget順序 | 動的 | ボトルネックに応じた最適化 |
| Widgetコンテンツ | 動的 | ラベル・プロンプトの文脈適応 |
| Widget間連動 | 動的 | Widget-to-Widget Reactivity |
| スタイル/見た目 | 固定 | 本研究の範囲外 |
| 配置/レイアウト | 半固定 | パターンから選択 |

### 3.2 判断基準の体系化

**固定すべき要素の基準：**
- ドメイン知識として事前に定義可能
- 固定することでLLMの判断負荷が軽減される
- UX品質を事前に担保できる

**動的にすべき要素の基準：**
- ユーザー入力に依存して変化する
- 固定すると「固定UIでいい」反論に勝てない
- 動的生成によりユーザー体験が向上する

---

## 4. Widget-to-Widget Reactivity

### 4.1 定義

- 同一画面上に複数のWidgetを配置
- ユーザーが一方を操作すると、他方がリアルタイムに更新
- **LLMは介在せず**、DpGで定義された依存関係に基づいて機械的に連動

### 4.2 研究における役割

1. **「JSONで選択結果を出せば十分」への反論：**
   - Widget選択だけならJSON出力で実現可能
   - しかしWidget間の連動関係は文脈依存で動的に決まる
   - この連動関係の定義こそがDSLシステムの価値

2. **「固定UIでいい」への反論：**
   - 固定UIでは連動パターンも固定される
   - ユーザーの悩みに応じて最適な連動パターンは異なる
   - 全パターンを事前定義するのは非現実的

### 4.3 Jellyとの差異

| 観点 | Jelly | 本研究 |
|------|-------|--------|
| 連動単位 | Item（データ項目） | Widget（UI部品） |
| 連動タイミング | 画面遷移時 | 同一画面上でリアルタイム |
| 定義方法 | DpGで動的生成 | DpGで動的生成（継承） |

---

## 5. 評価設計

### 5.1 Research Questions

| RQ | 内容 | 優先度 |
|----|------|-------|
| RQ1 | Widget-to-Widget Reactivityは適切に生成されるか？ | 高 |
| RQ2 | 生成されるUIフローは思考整理に適切か？ | 高 |
| RQ3 | Widget種類数とコンテキストウィンドウのトレードオフはどうか？ | 中 |
| RQ4 | LLMモデルの違いは生成品質にどう影響するか？ | 中 |

### 5.2 モデル比較実験

#### 検証したい仮説

1. **構造化出力ではCodexが優位か？**
2. **miniはどのタスクまで耐えられるか？**
3. **「診断・選択は賢いモデル、構造化は軽いモデル」は実用的か？**

#### タスクの分類

| タスク | 内容 | 特性 |
|--------|------|------|
| 診断 | ボトルネック診断 | 推論・分析 |
| 選択 | Widget選択 | 要件定義的・マッチング |
| OODM/DpG/DSL | 構造化出力 | 構文の正確性 |
| まとめ | 文章生成 | 要約・自然言語 |

#### 検証パターン（4パターン）

| パターン | 診断 | 選択 | OODM/DpG/DSL | まとめ | 狙い |
|---------|------|------|--------------|--------|------|
| A: 全部汎用 | GPT-5 | GPT-5 | GPT-5 | GPT-5 | 品質上限（ベースライン） |
| B: 全部mini | mini | mini | mini | mini | コスト下限・mini耐性の全体像 |
| C: 構造化Codex | GPT-5 | GPT-5 | Codex | GPT-5 | Codex優位性検証 |
| D: 構造化mini | GPT-5 | GPT-5 | mini | GPT-5 | 構造化でのmini耐性 |

#### パターン比較で検証できること

- **A vs B：** miniの全体的な耐性、どのタスクで品質劣化が顕著か
- **A vs C：** Codexの構造化出力での優位性、構文エラー率の差
- **A vs D：** 構造化タスクでのmini耐性、役割分担パターンの実用性
- **C vs D：** 構造化タスクでのCodex vs mini直接比較

#### 評価指標

| 指標 | 測定方法 |
|------|---------|
| 構文エラー率 | 自動検証 |
| 生成適切性 | 専門家評価 |
| レスポンス時間 | 計測 |
| 総コスト | トークン単価×使用量 |

#### 評価ケース

- 専門家評価10ケースを使用（状況に応じて5ケースに縮小可能）
- 各パターンで同一ケースを評価

### 5.3 専門家評価（10ケース）

#### ケース設計方針

- 8種類のボトルネックタイプを網羅
- Widget-to-Widget Reactivity活用ケースを5件含む
- 複雑度のバリエーション（低・中・高）

#### 評価項目

- ボトルネック診断の適切性
- Widget選択の適切性
- フロー構成の論理性
- Widget-to-Widget Reactivityの有効性
- Widgetコンテンツのカスタマイズ適合性
- 総合評価

### 5.4 ユーザー検証（5名）

#### 目的

- 技術的側面を重視（アプリのユーザビリティよりも動的UIシステムの評価）
- 実用性の示唆を得る

#### 評価項目

- UI適合度
- 思考整理効果の実感
- UI遷移の自然さ
- Reactivityの認識度

---

## 6. 論文構成方針

### 6.1 章立て

1. Introduction
2. Related Work
3. Proposed Method（設計パラダイムが中心）
4. Implementation（アーキテクチャ詳細、これから厚くする）
5. Evaluation
6. Discussion
7. Future Work
8. Conclusion

### 6.2 Chapter 3（Proposed Method）の構成

1. 問題提起：GeneralなシステムをDomain-Specificに導入する際の課題
2. 動的UI度ステージの整理（Stage 0-5）
3. システムアーキテクチャ：Widget方式の採用
4. Widget-to-Widget Reactivity
5. 設計空間の整理：何を固定し、何を動的にするか
6. 生成パイプライン

### 6.3 Future Work

- タスク実行フェーズの実装
- Context-Aware強化（デバイス情報活用）
- ローカルLLM / オンデバイス生成
- 他ドメインへの適用
- スタイル/見た目の動的生成（エンゲージメント向上目的）

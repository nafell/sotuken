# ドメイン特化型LLM動的UI生成システムの設計パラダイム
## ― 思考整理支援アプリケーションを題材として ―

---

# 1. Introduction

## 1.1 背景：UIの柔軟化への要求

コンピュータの普遍化に伴い、現代のアプリケーションには複雑な責務と多様な要望が求められるようになった **[事実：要出典]**。ユーザーの属性、利用状況、目的は多岐にわたり、単一のユーザーインターフェース（UI）で全員のニーズを満たすことは困難である。

アプリケーションは特定のユースケースに最適化することで「使いやすく」なる **[事実：UX研究の基本原則として出典あるはず]**。しかし、要望が多岐にわたる場合、すべてのユーザーに最適化されたUIを提供することには限度がある。この問題に対して、従来は以下のようなアプローチが取られてきた。

**固定UIアプリケーション**は、開発コストが低く、適合するユーザーにとっては利用コストが小さく利益が大きい。一方で、不適合なユーザーにとっては利用コストが大きく利益が小さい。

**カスタマイズ可能なUI**は、ユーザー自身が設定を変更できるため柔軟性があるが、開発コストが大きく、ユーザーにもカスタマイズの負担がかかる **[事実：設定画面の複雑さとユーザー離脱の関係は研究されているはず]**。

**従来的な自動UI生成**（ルールベース、テンプレートベース）は、一定の柔軟性を提供するが、適用可能な範囲が限定的である **[事実：Form生成などの先行研究]**。

近年、大規模言語モデル（LLM）の発展により、自然言語からコードを生成する能力が飛躍的に向上した **[事実：Codex, GPT-4等の論文]**。この技術を応用し、LLMによるリアルタイムUI生成という新たなアプローチが登場している。

## 1.2 背景：LLMによるリアルタイムUI生成の登場

LLMによるコーディング支援は、コード補完から始まり、自然言語の要望をコードに変換する機能、さらには自律的にコーディングを行うエージェントへと発展してきた **[事実：GitHub Copilot, Cursor, Devin等]**。

開発段階におけるLLMの活用では、専門家（プログラマ）がLLMの出力を検証・修正するため、LLMの不完全さは大きな問題にならない。すなわち「LLM → プログラマ → 利用者」という流れにおいて、プログラマがフィルターとして機能する。

しかし、リアルタイムUI生成では状況が異なる。「LLM → 利用者」という直接的な関係となり、専門家が介在しない。LLMの出力には再現性がなく、誤りも多い **[事実：LLMのhallucination等に関する研究]**。そのため、利用できないUI、使いづらいUI、問題を解決できないUIが生成される可能性がある。

**課題：LLMの不安定さ（再現性の欠如、誤り）をどのように制御し、実用的なUI生成を実現するか？**

## 1.3 既存研究：LLM-Hardened DSLによる解決

この課題に対して、LLM-Hardened DSLというアプローチが提案されている **[事実：Jelly論文等]**。LLM-Hardened DSLとは、LLMが扱いやすい形式のDomain Specific Language（DSL）を定義することで、LLMの出力の自由度を制限し、品質を担保する手法である。

LLMのミスや的外れな出力は、出力の自由度が高すぎることに起因する **[仮説：広く言われているが厳密な検証は少ないかも]**。DSLによってLLMが動ける範囲を定義し、考えるべき領域を狭めることで、狙い通りの結果を得やすくなる。また、余計なことを考えないため、本質的な推論に集中できる **[仮説]**。

Jellyは、このLLM-Hardened DSLを用いたGeneralな動的UI生成システムである **[事実：Jelly論文]**。Jellyでは、ユーザーによる初期プロンプトとUI操作を起点として、オブジェクト指向データモデル（OODM）および依存関係グラフ（DpG）をLLMが生成し、そこからDSLによるUI仕様書を生成、最終的にルールベースでHTMLなどの実際の記述にレンダリングする。

Jellyの研究により、LLM-Hardened DSLを用いた柔軟なUI生成が実現可能であることが示された **[事実：Jelly論文の結論]**。しかし、以下の課題が残されている：

1. **トークンコストの高さ**：GeneralなDSLは多くの要素を含む必要があり、プロンプトが長くなる
2. **生成品質の希釈**：プロンプトが長くなると、LLMの注意が分散し、生成品質が低下する可能性がある **[仮説：経験的には知られているが定量的検証は限定的]**
3. **継続的なユーザー入力の必要性**：Jellyではユーザーがテキストでプロンプトを与え続ける必要があり、プロアクティブに課題を捉えてくれない **[事実：Jelly論文の限界として記述されているはず]**

## 1.4 研究目的

本研究の主目的は、**ドメイン特化型LLM動的UI生成の設計パラダイムを確立すること**である。

GeneralなLLM動的UI生成システム（Jelly等）を特定ドメインに導入する際、単にシステムを適用すれば良いわけではない。ドメインの特性に応じて、「何を固定し、何を動的にすべきか」を判断する必要がある。本研究では、この判断基準を明らかにし、設計判断の経緯と論理を体系化する。

副次的な目的として、以下を検証する：
- Widget-to-Widget Reactivityという手法により、ドメイン特化においても動的生成が必要であることを実証する
- ドメイン特化によるトークン削減効果を検証する

## 1.5 研究の貢献

本研究の貢献は以下の3点である：

1. **設計パラダイムの提示**：ドメイン特化型動的UIシステムにおいて、何を固定し何を動的にすべきかの判断基準を体系化する。動的UI度を6段階に整理し、各段階の特性とDSLシステム導入の妥当性を論じる。

2. **Widget-to-Widget Reactivityの提案**：同一画面上でのWidget間連動を動的に生成する手法を提案する。これにより、「固定UIで十分」「JSON出力で十分」という反論に対する回答を提供する。

3. **思考整理アプリでの実証**：提案手法の有効性を、思考整理支援という具体的なドメインで検証する。

---

# 2. Related Work

## 2.1 LLMによるUI生成

LLMを用いたUI生成に関する研究は近年急速に発展している **[事実：サーベイ論文があるはず]**。

**Jelly** **[事実：論文引用]** は、GeneralなLLM-Hardened DSLによる動的UI生成システムである。Siri や Google Assistant のような「何でもコンシェルジュ」に近い位置づけであり、ユーザーが複数のアプリやWebサービスを行き来して行うような日常的なタスクをワンストップで支援する。

Jellyのアーキテクチャは3層構造を採用している：
- **Layer 1: Object-Oriented Data Model (OODM)**：セッション全体で扱うデータ構造を定義
- **Layer 2: Dependency Graph (DpG)**：データ間の依存関係を定義
- **Layer 3: UI Specification (DSL)**：具体的なUI要素を定義

Jellyでは、データ項目間の連動（Item-to-Item Reactivity）により、あるデータの変更が他のデータや表示に自動的に反映される。

**本研究との差異**：Jellyは General な用途を想定しているのに対し、本研究は Domain-Specific（思考整理）に特化する。また、連動の単位がJellyではItem（データ項目）であるのに対し、本研究ではWidget（UI部品）である。

**その他のLLM UI生成研究** **[要追加調査]** についても、動的生成の粒度、ドメイン特化の有無、ユーザー入力の必要性といった軸で比較・整理する必要がある。

## 2.2 LLM-Hardened DSL

LLM-Hardened DSLは、LLMの出力自由度を制限することで品質を担保する手法である **[事実：用語の出典確認]**。

DSLの設計には大きく2つのアプローチがある：
- **宣言型（JSON等）**：UIの状態や構造を宣言的に記述する
- **手続き型**：UIの生成手順を記述する

この分類は、従来的なUIフレームワーク（React vs jQuery等）の分類と発想が共通している **[事実：UIフレームワークの歴史]**。

本研究は宣言型DSLをドメイン特化させるアプローチを採用する。

## 2.3 思考整理支援ツール

思考整理を支援するツールは多数存在する **[事実：各ツールの存在]**：
- マインドマップツール（MindMeister, XMind等）
- タスク管理アプリ（Todoist, Notion等）
- 思考整理専用ツール（Miro, FigJam等）

これらのツールに共通する限界は、**UIが固定であり、ユーザーの悩みに適応しない**ことである。ユーザーは自分の状況に合ったツールや機能を自ら選択する必要があり、そもそも何から考えればいいか分からないユーザーにとってはハードルが高い **[仮説：ユーザー調査で検証可能]**。

本研究は、ユーザーの悩みに応じてUIフロー全体を動的に生成することで、この限界を克服する。

---

# 3. Proposed Method

## 3.1 問題提起：GeneralなシステムをDomain-Specificに導入する際の課題

### 3.1.1 Jellyの特性と限界

JellyはSiri/Google Assistantに近い「何でもコンシェルジュ」である **[事実：Jelly論文の位置づけ]**。用途が決められていないため、あらゆるUIパターンを単純な部品（Atom）の組み合わせで表現する必要がある。そのためDSLの規則が複雑になり、プロンプトに含める情報量が多くなる。

結果として、以下の問題が生じる：
- トークンコストが高い
- プロンプトが長くなり、LLMの注意が分散する **[仮説]**
- 特定タスクには不要な要素まで考慮させてしまう

### 3.1.2 ドメイン特化の必要性

特定ドメインでLLM動的UI生成システムを使用する場合、Generalなシステムをそのまま導入すれば良いわけではない。

ドメイン特化することで、以下のメリットが期待できる **[仮説：本研究で検証]**：
- 不要な要素を省くことでトークンコストを削減できる
- ドメイン知識を事前に埋め込むことで、LLMの判断負荷を軽減できる
- UX品質を事前に担保できる

しかし、ドメイン特化には本質的な問いが伴う：

**「固定UIで良いところと動的にすべきところをどう見極めるか？」**

ドメインが特定されているなら、「100パターンのUIを用意すれば十分ではないか」「動的生成は過剰ではないか」という反論が生じる。本研究は、この反論に答えることを重要な課題とする。

## 3.2 動的UI度ステージ：どこまで動的にすべきか

ドメイン特化型システムにおいて、UIの動的生成をどの程度行うかには段階がある。本研究では、動的UI度を6段階（Stage 0-5）に整理する。

### 3.2.1 6段階の定義

| Stage | 動的要素 | UI部品 | 説明 |
|-------|---------|--------|------|
| 0 | なし | 固定UI | 完全に固定されたUI |
| 1 | コンテンツ（アルゴリズミック） | 固定UI | ルールベースでコンテンツを生成 |
| 2 | コンテンツ（LLM） | 固定UI | LLMでコンテンツを生成 |
| 3 | Widget選択 + コンテンツカスタマイズ | Widget | LLMがWidgetを選び、内容を調整 |
| 4 | Widget間インタラクション定義 | Widget | LLMがWidget間の連動ルールを定義 |
| 5 | Widget構造自体（Atomから構築） | Atom | LLMがAtomからUIを組み上げる |

**Stage 0-2**は従来の固定UIアプリケーションの延長であり、「動的UI生成」と呼ぶには不十分である。UIの構造自体は変化せず、表示されるコンテンツのみが変化する。

**Stage 5**はJellyが採用しているアプローチであり、最大の柔軟性を持つが、Generalな用途を前提としている。

**Stage 3-4**がドメイン特化型システムの設計空間となる。本研究では、この2つの段階の違いを明確にし、どちらを採用すべきかを論じる。

### 3.2.2 Stage 3はオーバーエンジニアリングである

**主張：Stage 3のためにDSLベースの動的UI生成システムを導入する価値はない。**

Stage 3の定義は「LLMがWidgetを選択し、コンテンツをカスタマイズする」である。一見すると動的UI生成に見えるが、Stage 2（固定UI + LLMコンテンツ生成）との本質的な差分は小さい。

Stage 3で行われることを分解すると：
1. LLMがどのWidgetを使うか選択する
2. 選択されたWidgetに表示するコンテンツをLLMがカスタマイズする

しかし、(1)はJSON出力で十分実現可能である。LLMに「この状況ではどのWidgetを使うべきか」と問い、結果をJSON形式で受け取り、対応する固定UIコンポーネントを表示すればよい。(2)も同様に、各Widgetにデータを渡すだけで実現できる。

つまり、Stage 3は以下のような単純な実装で実現可能である：

```
1. LLM呼び出し: "どのWidgetを使うべきか？" → {"widgets": ["A", "B", "C"]}
2. 各Widgetにコンテンツを渡して表示
```

この実装において、DSLで依存関係グラフを定義するシステムは不要である。OODM/DpG/DSLという3層アーキテクチャは、Stage 3に対しては**オーバーエンジニアリング**である **[仮説：本研究の主張]**。

### 3.2.3 本研究はStage 4を採用する

**主張：Stage 4でこそDSLシステムの価値が正当化される。**

Stage 4の定義は「LLMがWidget間のインタラクション（連動ルール）を動的に定義する」である。Stage 3との決定的な違いは、**「見た目」だけでなく「動作」をLLMが生成する**ことである。

Stage 3では、LLMは「何を表示するか」を決定する。しかし、表示されたWidgetがどのように連動するか（ユーザーがWidget Aを操作したときにWidget Bがどう変化するか）は事前に固定されている。

Stage 4では、LLMはこの連動ルール自体を生成する。連動パターンは文脈依存であり、事前に全パターンを定義することは非現実的である **[仮説：ケーススタディで検証]**。ここにDSLシステムを導入する価値がある。

#### 具体例1：優先度評価UI

**Stage 3の場合：**
LLMは「優先度スライダーを使う」「項目はA, B, Cである」という選択とコンテンツを生成する。スライダーを動かすとランキングが更新されるという動作は事前に実装されている。すべてのケースで同じ計算式（例：単純な重み付け平均）が使われる。

**Stage 4の場合：**
LLMは「ユーザーが緊急度・重要度・工数のスライダーを操作すると、その重み付けに基づいてランキングがリアルタイムに更新される」という連動ルール自体を生成する。どの軸をどう組み合わせてランキングに反映するかは、ユーザーの悩みの文脈によって異なる。

例えば、「締め切りが迫っている」というユーザーには緊急度を重視した計算式を、「長期的なキャリアを考えたい」というユーザーには重要度を重視した計算式を、LLMが文脈に応じて生成する。

#### 具体例2：依存関係マッピング

**Stage 3の場合：**
LLMは「依存関係図を使う」「ノードは仕事・健康・家族である」と生成する。ノード間の接続を可視化する機能は事前に実装されている。

**Stage 4の場合：**
LLMは「ユーザーがノード間を接続すると、最も影響が大きい経路（クリティカルパス）が右側に自動でハイライトされる」という連動ルールを生成する。何をクリティカルパスとみなすか（最長経路か、影響度の積が最大の経路か、等）は、ユーザーの問題構造によって異なる。

### 3.2.4 Stage 5を採用しない理由

Stage 5（Atomから組み上げ）は最大の柔軟性を持つが、ドメイン特化型システムには以下の理由で適さない **[仮説]**：

1. **UX品質の担保が困難**：LLMが毎回ゼロからUIを組み上げると、最適なUXが生成される保証がない。ドメイン特化ならば、有効なUIパターンをWidgetとして事前定義し、UX品質を担保できる。

2. **トークンコストの増大**：Atomの組み合わせ方をすべてプロンプトに含める必要があり、トークンコストが増大する。

3. **ドメイン知識の活用困難**：Generalなシステムはドメイン知識を持たないため、LLMがドメインに適したUIパターンを「発見」する必要がある。ドメイン特化ならば、この知識を事前に埋め込める。

### 3.2.5 独立軸として扱う要素

動的UI度のステージとは別に、以下の要素は独立した軸として扱う：

**スタイル/見た目（色、サイズ、アイコン等）**：本研究では固定とする。スタイルの動的生成はエンゲージメント向上を目的とした別の研究領域であり、タスク達成を目的とする本研究の範囲外である。

**配置/レイアウト**：本研究では半固定（パターンから選択）とする。配置の最適化は、ダッシュボードや広告など視線誘導が重要な場合に有効であるが、思考整理では上から順番に処理すれば良いため、重要度が低い。

## 3.3 システムアーキテクチャ：Widget方式の採用

### 3.3.1 Jellyからの継承：3層アーキテクチャ

本研究は、Jellyが提案した3層アーキテクチャを継承する **[事実：Jelly論文]**：

**Layer 1: Object-Oriented Data Model (OODM)**
セッション全体で扱うデータ構造を定義する。ユーザーの入力、各Widgetの出力、Widget間で共有されるデータの型と関係を記述する。

**Layer 2: Dependency Graph (DpG)**
データ間の依存関係を定義する。あるデータが変更されたときに、どのデータや表示が影響を受けるかを記述する。

**Layer 3: UI Specification (DSL)**
具体的なUI要素を定義する。どのWidgetを使い、どのような設定で表示するかを記述する。

### 3.3.2 Widgetとは何か

本研究におけるWidgetとは、**特定の思考整理タスクを支援するための、事前定義されたUI部品**である。

Widgetは単なるボタンやテキストフィールドといった原子的なUI要素（Atom）ではなく、特定の目的を持った複合的なUI部品である。例えば「優先度スライダーグリッド」Widgetは、複数の軸に対するスライダーと、その結果を表示するランキング表示を組み合わせた複合部品である。

**Jellyとの違い：**
- Jelly：Atom（原子部品）からUIを動的に組み上げる（Stage 5相当）
- 本研究：Widget（複合部品）を事前定義し、選択・組み合わせ・連動を動的に行う（Stage 4）

### 3.3.3 Widget方式を採用する理由

Widget方式を採用する理由は3つある **[仮説：本研究で検証]**：

**1. UX品質の担保**
各Widgetは事前にUXを設計・検証済みである。「優先度スライダーグリッド」というWidgetが思考整理に有効であることは、設計時に検討されている。LLMは「どのWidgetを使うか」を判断するだけでよく、Widget内部のUXを毎回設計する必要がない。

**2. トークン削減**
Widgetの内部構造をLLMに説明する必要がない。「優先度スライダーグリッド」という名前と簡単な説明をプロンプトに含めるだけで、LLMはそのWidgetを選択できる。AtomレベルでUIを記述する場合と比較して、大幅なトークン削減が期待できる **[仮説：実験で検証]**。

**3. ドメイン知識の埋め込み**
思考整理に有効なUIパターンをWidgetとして事前定義することで、ドメイン知識をシステムに埋め込める。LLMはこの知識を活用して、適切なWidgetを選択できる。

### 3.3.4 ドメイン特化による変更点

3層アーキテクチャをドメイン特化させることで、以下の変更が生じる：

| 層 | Jelly（General） | 本研究（Domain-Specific） |
|----|-----------------|-------------------------|
| OODM | 任意のデータ構造を動的に定義 | 思考整理特化のデータ型を事前定義 |
| DpG | Item-to-Item | Widget-to-Widget |
| DSL | Atomから組み上げ | 事前定義Widgetから選択 |

OODMにおいては、思考整理で頻出するデータ型（感情データ、選択肢リスト、優先度スコア等）を事前に定義しておくことで、LLMの生成負荷を軽減する。

DpGにおいては、連動の単位をItem（データ項目）からWidget（UI部品）に変更する。これにより、Widget-to-Widget Reactivityが実現される。

DSLにおいては、Atomの組み合わせではなく、事前定義されたWidgetの選択と設定を記述する。

## 3.4 Widget-to-Widget Reactivity

### 3.4.1 定義

Widget-to-Widget Reactivityとは、同一画面上に配置された複数のWidgetが、ユーザーの操作に応じてリアルタイムに連動する仕組みである。

重要な特徴として、**連動時にLLMは介在しない**。連動ルールはDpGとして事前にLLMが生成しており、実際の連動はそのルールに基づいて機械的に実行される。これにより、リアルタイムな応答性が確保される。

### 3.4.2 研究における役割

Widget-to-Widget Reactivityは、本研究において以下の2つの反論に対する回答として機能する：

**反論1：「JSON出力で選択結果を出せば十分ではないか」**

Stage 3（Widget選択 + コンテンツカスタマイズ）は、確かにJSON出力で実現可能である。しかし、Widget間の連動関係は文脈依存で動的に決まる。

例えば、「スライダーを動かすとランキングが更新される」という連動において、どのような計算式でランキングを算出するかはユーザーの悩みによって異なる。この連動ルールの定義こそが、DSLシステムを導入する価値である。

**反論2：「ドメイン特化なら固定UIで十分ではないか」**

固定UIでは連動パターンも固定される。しかし、ユーザーの悩みに応じて最適な連動パターンは異なる。

思考整理における悩みは、「選択肢が多すぎる」「何から考えればいいか分からない」「感情的なブロックがある」など多様である。それぞれの悩みに対して最適な連動パターンは異なり、全パターンを事前に定義することは非現実的である **[仮説：ケーススタディで検証]**。

### 3.4.3 Jellyとの差異

| 観点 | Jelly | 本研究 |
|------|-------|--------|
| 連動単位 | Item（データ項目） | Widget（UI部品） |
| 連動タイミング | 画面遷移時 | 同一画面上でリアルタイム |
| 定義方法 | DpGで動的生成 | DpGで動的生成（継承） |

JellyのItem-to-Item Reactivityは、データ項目間の依存関係を定義する。例えば、「参加者リストが更新されると、食事制限の集計も更新される」といった関係である。

本研究のWidget-to-Widget Reactivityは、UI部品間の依存関係を定義する。例えば、「スライダーWidgetの値が変わると、ランキングWidgetの表示が更新される」といった関係である。

連動タイミングの違いも重要である。Jellyでは連動は主に画面遷移時に発生するが、本研究では同一画面上でリアルタイムに連動が発生する。これにより、ユーザーは自分の操作が即座に結果に反映されることを体験でき、思考の試行錯誤が促進される **[仮説]**。

### 3.4.4 Reactivityの種類

Widget間の依存関係には、以下の種類がある：

**data_input**：前WidgetのステップOutputを、次Widgetのステップ入力データとして使用する。例えば、ブレインストームで出たアイデアリストを、カード仕分けWidgetの入力として使用する。

**config_input**：前Widgetの出力を、次Widgetの設定（ラベル、プロンプト等）に反映する。例えば、感情カラーパレットで選択された感情を、マトリックスUIの軸ラベルに反映する。

**reactive_binding**：同一画面上でのリアルタイム連動。例えば、スライダーの値が変わるとランキングが即座に更新される。

## 3.5 設計空間の整理：何を固定し、何を動的にするか

### 3.5.1 判断結果

本研究における設計判断を以下に整理する：

| 要素 | 固定/動的 | 理由 |
|------|----------|------|
| Widget種類 | 固定 | UX品質担保、トークン削減 |
| フロー構造 | 半固定 | ドメイン知識（発散→整理→収束） |
| Widget選択 | 動的 | ユーザーの悩みに適応 |
| Widget順序 | 動的 | ボトルネックに応じた最適化 |
| Widgetコンテンツ | 動的 | ラベル・プロンプトの文脈適応 |
| Widget間連動 | 動的 | Widget-to-Widget Reactivity |
| スタイル/見た目 | 固定 | 本研究の範囲外 |
| 配置/レイアウト | 半固定 | パターンから選択 |

### 3.5.2 判断基準の体系化

上記の判断は、以下の基準に基づいている：

**固定すべき要素の基準：**
1. ドメイン知識として事前に定義可能である
2. 固定することでLLMの判断負荷が軽減される
3. UX品質を事前に担保できる

**動的にすべき要素の基準：**
1. ユーザー入力に依存して変化する
2. 固定すると「固定UIでいい」という反論に勝てない
3. 動的生成によりユーザー体験が向上する

Widget種類を固定する判断は、基準1（ドメイン知識として事前定義可能）と基準3（UX品質担保）に基づく。思考整理に有効なUIパターンは研究や実践で蓄積されており、これをWidgetとして事前定義できる **[事実：思考整理手法の研究]**。

Widget間連動を動的にする判断は、基準1（ユーザー入力に依存）と基準2（固定UIとの差別化）に基づく。最適な連動パターンはユーザーの悩みによって異なり、ここを動的にすることでDSLシステムの価値が正当化される。

## 3.6 生成パイプライン

本システムの生成パイプラインは以下の通りである：

```
1. Capture Data（ユーザー入力）
   - 悩みのテキスト、タグ、問診への回答
   
2. LLM: ボトルネック診断
   - ユーザーの思考を妨げている要因を特定
   - 8種類のボトルネックタイプから診断
   
3. LLM: OODM + DpG生成
   - データ構造の定義
   - Widget選択
   - Widget間の連動ルール定義（Widget-to-Widget Reactivity）
   
4. LLM: DSL生成
   - Widgetコンテンツのカスタマイズ
   - ラベル、プロンプト、選択肢等の文脈適応
   
5. Renderer: UI描画
   - DSLを解釈してUIを描画
   
6. ユーザー操作 → Reactive更新
   - DpGに基づいて機械的に連動（LLM不介在）
```

ステップ2-4はLLMを使用するが、ステップ6のReactive更新ではLLMを使用しない。これにより、リアルタイムな応答性が確保される。

---

# 4. Implementation

## 4.1 思考整理支援アプリの概要

### 4.1.1 なぜ思考整理を題材としたか

本研究では、提案する設計パラダイムの検証フィールドとして思考整理支援アプリを選択した。この選択には以下の理由がある：

**多様性**：思考整理における悩みの内容、状況、ユーザーの背景は多様である。単一のUIで全てのケースに対応することは困難であり、動的UI生成の価値を実証しやすい。

**文脈依存性**：最適な思考整理手法は、悩みの性質によって異なる。「選択肢が多すぎる」場合と「何から考えればいいか分からない」場合では、有効なアプローチが異なる **[事実：思考整理・問題解決の研究]**。

**固定UIの限界**：既存の思考整理ツール（マインドマップ、タスク管理等）は固定UIであり、ユーザーが自分に合ったツールを選ぶ必要がある。これは「何から考えればいいか分からない」ユーザーにとってハードルが高い。

**カスタマイズの困難さ**：悩みは漠然としていることが多く、ユーザー自身がUIをカスタマイズすることも困難である。LLMがユーザーの代わりに最適なUIを選択する価値がある。

注意すべき点として、本研究の主題は思考整理アプリのUXではなく、ドメイン特化型動的UI生成の設計パラダイムである。思考整理は検証フィールドであり、アプリの有効性自体は副次的な評価対象である。

### 4.1.2 アプリ構成

アプリは3つのフェーズで構成される：

**Capture Phase**：ユーザーの悩みを入力・構造化するフェーズ。悩みのテキスト入力、タグ付け（LLM提案の選択肢から選択）、追加質問（問診）を行う。

**Plan Phase**：思考整理を行うフェーズ。本研究の主対象である。ユーザーの悩みに応じて動的にUIが生成され、思考整理を支援する。

**Breakdown Phase**：思考整理の結果をタスクに分解するフェーズ。本研究では簡易実装とする。

## 4.2 Plan Phaseの設計

### 4.2.1 3ステージ構造

Plan Phaseは、思考整理の一般的なプロセスに基づき、3ステージ構造を採用する **[事実：発散・収束思考の研究、デザイン思考等]**：

**Stage 1: 発散・探索 (Diverge)**
可能性を広げ、選択肢を増やすステージ。制約なく自由にアイデアを出したり、感情を可視化したりする。

**Stage 2: 整理・評価 (Organize)**
出てきた選択肢を構造化し、関係性を把握するステージ。カテゴリー分け、依存関係の可視化、多角的な評価を行う。

**Stage 3: 収束・決定 (Converge)**
優先順位をつけ、方針を確定するステージ。選択肢を絞り込み、最終的な決定を行う。

**Stage 4: まとめ (Summary)**
思考整理の結果を構造化された文章で確認し、必要に応じて修正するステージ。

この3+1ステージ構造は「半固定」である。すべてのユーザーがこの順序で進むが、各ステージ内でどのWidgetを使うかは動的に決定される。

### 4.2.2 ボトルネック診断

LLMは、Capture Phaseの情報からユーザーの思考を妨げている要因（ボトルネック）を診断する。本研究では、以下の8種類のボトルネックタイプを定義する：

1. **選択肢が多すぎる**：可能性がありすぎて絞れない
2. **何から考えればいいか分からない**：白紙状態、取っ掛かりがない
3. **複数の問題が絡んでいる**：問題同士が影響し合っている
4. **感情的ブロック**：不安、恐れ、罪悪感が思考を妨げている
5. **情報不足**：断片的な情報、全体像が見えない
6. **決断への恐れ**：失敗が怖い、後戻りできない感覚
7. **視点固定**：一つの見方しかできない、思い込みがある
8. **優先順位がつけられない**：すべてが同じくらい重要に見える

ボトルネック診断の結果は、Widget選択とWidget間連動の定義に影響を与える。

## 4.3 Widgetライブラリ

（実装詳細は別途記述）

12種類のWidgetを事前定義する。各Widgetには以下のメタデータを付与する：
- **timing**：推奨される使用タイミング（0.0=序盤、1.0=終盤）
- **versatility**：汎用性スコア
- **対応ボトルネック**：どの思考障壁に有効か

## 4.4 Widget-to-Widget Reactivityの実装例

（実装詳細は別途記述）

## 4.5 DSL仕様

（実装詳細は別途記述）

---

# 5. Evaluation

## 5.1 評価の目的と構成

本研究の評価は、以下のResearch Questionsに答えることを目的とする：

**RQ1: Widget-to-Widget Reactivityは適切に生成されるか？**
LLMが生成する連動ルールが、構文的に正しく、意味的に妥当であるかを検証する。

**RQ2: 生成されるUIフローは思考整理に適切か？**
Widget選択、順序、コンテンツカスタマイズが、ユーザーの悩みに対して適切であるかを検証する。

**RQ3: Widget種類数とコンテキストウィンドウのトレードオフはどうか？**
Widget数を増やすとプロンプトが長くなり、生成品質に影響する可能性がある。この関係を検証する。

**RQ4: LLMモデルの違いは生成品質にどう影響するか？**
汎用モデル、コーディング特化モデル、低コストモデルの性能を比較し、役割分担の知見を得る。

## 5.2 実験1: 技術性能評価

### 5.2.1 トークン使用量

各生成ステップ（OODM、DpG、DSL）でのトークン使用量を測定する。Widget数を変化させた場合の影響も検証する。

### 5.2.2 生成成功率

構文エラー率、実行エラー率、Reactivity定義の妥当性を測定する。

### 5.2.3 レスポンス時間

各生成ステップの時間と、総レスポンス時間を測定する。

## 5.3 実験2: Widget数とコンテキストウィンドウのトレードオフ

### 5.3.1 実験設計

Widget数を変化させ（6個 / 9個 / 12個 / 15個）、各条件での生成品質を比較する。

### 5.3.2 評価項目

- プロンプト長（トークン数）
- 生成成功率
- Widget選択の適切性（専門家評価）

### 5.3.3 仮説

**仮説3-1**：Widget数が増えるとプロンプトが長くなり、生成成功率が低下する **[仮説]**。

**仮説3-2**：ある閾値を超えるとコンテキストウィンドウの逼迫により、品質が急激に低下する **[仮説]**。

**仮説3-3**：最適なWidget数は、機能性と生成品質のトレードオフで決まる **[仮説]**。

## 5.4 実験3: モデル比較

### 5.4.1 検証したい仮説

**仮説4-1**：構造化出力（OODM/DpG/DSL生成）では、コーディング特化モデル（Codex）が汎用モデルより優位である **[仮説]**。

**仮説4-2**：低コストモデル（mini）は、構造化出力タスクでは品質が低下するが、一部のタスクでは十分な性能を発揮する **[仮説]**。

**仮説4-3**：「診断・選択は賢いモデル、構造化は軽いモデル」という役割分担が実用的である **[仮説]**。

### 5.4.2 タスクの分類

LLMが担うタスクを以下のように分類する：

| タスク | 内容 | 特性 |
|--------|------|------|
| 診断 | ボトルネック診断 | 推論・分析が必要 |
| 選択 | Widget選択 | 要件定義的・マッチング |
| OODM/DpG/DSL | 構造化出力 | 構文の正確性が重要 |
| まとめ | 文章生成 | 要約・自然言語 |

### 5.4.3 検証パターン

以下の4パターンで比較実験を行う：

| パターン | 診断 | 選択 | OODM/DpG/DSL | まとめ | 狙い |
|---------|------|------|--------------|--------|------|
| A: 全部汎用 | GPT-5 | GPT-5 | GPT-5 | GPT-5 | 品質上限（ベースライン） |
| B: 全部mini | mini | mini | mini | mini | コスト下限・mini耐性 |
| C: 構造化Codex | GPT-5 | GPT-5 | Codex | GPT-5 | Codex優位性検証 |
| D: 構造化mini | GPT-5 | GPT-5 | mini | GPT-5 | 構造化でのmini耐性 |

### 5.4.4 評価指標

- 構文エラー率（自動検証）
- 生成適切性（専門家評価）
- レスポンス時間
- 総コスト

## 5.5 実験4: 専門家評価（10ケース）

### 5.5.1 サンプルケース設計

8種類のボトルネックタイプを網羅し、Widget-to-Widget Reactivity活用ケースを5件含む10ケースを設計する。複雑度のバリエーション（低・中・高）も考慮する。

### 5.5.2 評価項目

- ボトルネック診断の適切性
- Widget選択の適切性
- フロー構成の論理性
- Widget-to-Widget Reactivityの有効性
- Widgetコンテンツのカスタマイズ適合性
- 総合評価

## 5.6 実験5: ユーザー検証（5名）

### 5.6.1 目的

技術的側面を重視し、動的UIシステムの評価を行う。アプリのユーザビリティ自体は副次的な評価対象である。

### 5.6.2 評価項目

- UI適合度（生成されたUIが自分に合っていたか）
- 思考整理効果の実感
- UI遷移の自然さ
- Reactivityの認識度（Widget間の連動に気づいたか）

## 5.7 結果（予定）

（実験結果に基づいて記述）

---

# 6. Discussion

## 6.1 設計パラダイムの妥当性

### 6.1.1 Stage 4の選択は適切だったか

本研究はStage 4（Widget間インタラクション定義）を採用した。この選択が適切であったかを、以下の観点から考察する。

**Stage 3を避けた効果**：Stage 3では「オーバーエンジニアリング」であると論じた。実験結果から、Widget選択のみであればJSON出力で十分であることが確認されれば、この主張は支持される **[仮説：実験で検証]**。

**Stage 5を避けた効果**：Stage 5（Atomから組み上げ）を避けたことで、UX品質の担保とトークン削減が実現されたかを検証する **[仮説：実験で検証]**。

### 6.1.2 固定と動的の判断は適切だったか

3.5節で示した判断基準に基づく設計判断が適切であったかを、以下の観点から考察する：

- トークン削減効果
- 生成品質
- ユーザー体験

### 6.1.3 他ドメインへの適用可能性

本研究で確立した設計パラダイムが、思考整理以外のドメインにも適用可能であるかを考察する。

**一般化可能な部分** **[仮説]**：
- 動的UI度ステージの分類
- 「何を固定し、何を動的にするか」の判断基準
- Widget方式の採用

**ドメイン固有の調整が必要な部分** **[仮説]**：
- Widgetの種類と数
- ボトルネック診断の内容
- フロー構造

## 6.2 Widget-to-Widget Reactivityの効果

### 6.2.1 「JSON出力で十分」への回答

Widget-to-Widget Reactivityにより、「JSON出力で十分」という反論に対して回答できたかを考察する。

連動ルールの動的生成が価値を持つケースと、固定の連動ルールで十分なケースがあるかもしれない。実験結果から、どのようなケースでWidget-to-Widget Reactivityが特に有効であったかを分析する **[仮説：実験で検証]**。

### 6.2.2 「固定UIでいい」への回答

固定UIでは得られない体験が、Widget-to-Widget Reactivityにより実現されたかを考察する。

文脈依存の連動パターンが、ユーザーの思考整理にどのように寄与したかを分析する **[仮説：実験で検証]**。

### 6.2.3 Reactivityパターンの類型化

有効だったReactivityパターンと、うまくいかなかったパターンを類型化する。これにより、今後のWidget設計に対する示唆を得る **[仮説：実験で検証]**。

## 6.3 Widget数のトレードオフに関する知見

### 6.3.1 発見された閾値・傾向

Widget数とコンテキストウィンドウのトレードオフに関して、実験から得られた知見を整理する。

コンテキストウィンドウ逼迫が発生する条件、機能性と生成品質のバランスポイントを明らかにする **[仮説：実験で検証]**。

### 6.3.2 実務への示唆

ドメイン特化型動的UIシステムを設計する際の、Widget数に関する指針を提示する **[仮説：実験結果に基づく]**。

## 6.4 モデル選択に関する知見

### 6.4.1 タスク別の推奨モデル

実験結果に基づき、各タスク（診断、選択、構造化出力、まとめ）に対する推奨モデルを提示する **[仮説：実験で検証]**。

### 6.4.2 役割分担の実用性

「賢いモデルと軽いモデルの役割分担」というアプローチの実用性を考察する。コスト削減効果と品質への影響を分析する **[仮説：実験で検証]**。

## 6.5 制約と限界

### 6.5.1 技術的制約

- LLMの生成品質への依存
- レスポンス時間
- コスト

### 6.5.2 評価の限界

- サンプルサイズ（専門家評価10ケース、ユーザー検証5名）
- 短期的な評価（長期利用の効果は未検証）
- 思考整理という単一ドメインでの検証

---

# 7. Future Work

## 7.1 タスク実行フェーズの実装

Breakdown Phaseで生成されたタスクの実行を支援するフェーズの実装。アプリを開くたびに、その時点で最も重要なタスクを動的に生成されたUIで強調表示することで、タスク実行を促進する **[仮説]**。

## 7.2 Context-Aware強化

デバイス情報（曜日、時刻、空き時間、現在地、画面サイズ等）を活用し、状況に応じたUI最適化を行う。例えば、通勤中（スマートフォン、短時間）と自宅（PC、長時間）で異なるWidgetを提示する **[仮説]**。

## 7.3 ローカルLLM / オンデバイス生成

ネットワーク非依存の動作、プライバシー配慮が必要なタスクへの対応を目的として、スマートフォン上でのローカルLLM実行を検討する。トークン削減がドメイン特化の副次効果であることから、ローカルLLMとの親和性が高い可能性がある **[仮説]**。

## 7.4 スタイル/見た目の動的生成

本研究では範囲外としたスタイル/見た目の動的生成を、エンゲージメント向上を目的として研究する。タスク達成とは異なる評価軸が必要になる **[仮説]**。

## 7.5 他ドメインへの適用

本研究で確立した設計パラダイムを、思考整理以外のドメイン（教育、医療相談、カウンセリング等）に適用し、一般化可能性を検証する **[仮説]**。

---

# 8. Conclusion

本研究は、ドメイン特化型LLM動的UI生成の設計パラダイムを提示した。

まず、動的UI度を6段階（Stage 0-5）に整理し、各段階の特性とDSLシステム導入の妥当性を論じた。Stage 3（Widget選択 + コンテンツカスタマイズ）はJSON出力で十分実現可能であり、DSLシステムは「オーバーエンジニアリング」であると主張した。一方、Stage 4（Widget間インタラクション定義）では、連動ルールの動的生成によりDSLシステムの価値が正当化されることを示した。

次に、「何を固定し、何を動的にすべきか」の判断基準を体系化した。Widget種類やフロー構造は固定または半固定とし、Widget選択、順序、コンテンツ、連動は動的とする設計判断を示した。この判断は、「ドメイン知識として事前定義可能か」「固定UIとの差別化になるか」「ユーザー体験が向上するか」という基準に基づく。

Widget-to-Widget Reactivityを提案し、「JSON出力で十分」「固定UIでいい」という反論に対する回答を提供した。同一画面上でのWidget間連動を動的に定義することで、文脈依存の思考整理支援が可能になる。

思考整理支援アプリを題材に、提案手法の有効性を検証した。技術性能評価、専門家評価、ユーザー検証を通じて、設計パラダイムの妥当性を確認した **[実験結果に基づいて記述]**。

また、Widget数とコンテキストウィンドウのトレードオフ、LLMモデル比較など、実践的な知見を得た **[実験結果に基づいて記述]**。

本研究で確立した設計パラダイムは、思考整理に限らず、他のドメイン特化型動的UIシステムの設計にも適用可能である。「何を固定し、何を動的にすべきか」という問いは、あらゆるドメイン特化型システムに共通する設計課題であり、本研究の知見はその指針となる。

# 卒業論文アウトライン
## ドメイン特化型LLM動的UI生成システムの設計パラダイム ― 思考整理支援アプリケーションを題材として

---

## 1. Introduction

### 1.1 背景：UIの柔軟化への要求
- コンピュータの普遍化により、現代のアプリケーションには複雑な責務と多様な要望が求められる
- アプリは特定のユースケースに最適化することで「使いやすく」なる
- しかし、要望が多岐に渡ると機能/UIを全員に最適化することには限度がある
- **問い：LLMでUIを動的生成すれば解決できるのでは？**

### 1.2 背景：LLMによるリアルタイムUI生成の登場
- LLMによるコーディングの発展（コード補完→自然言語変換→自律エージェント）
- 開発段階ではプログラマが介在するため、LLMの不完全さを補完できる
- しかし、リアルタイム生成では専門家が介在しない（LLM→利用者）
- **課題：LLMの不安定さ（再現性、誤り）をどう制御するか？**

### 1.3 既存研究：LLM-Hardened DSLによる解決
- LLM-Hardened DSL：LLMが扱いやすいDSLを定義し、出力の自由度を制限する手法
- Jellyの成果：GeneralなDSLで柔軟なUI生成を実現
- **残された課題：**
  1. GeneralなDSLはトークンコストが高い
  2. プロンプトが長くなり生成品質が希釈される
  3. ユーザーが継続的にプロンプトを与える必要がある

### 1.4 研究目的
- **主目的：ドメイン特化型LLM動的UI生成の設計パラダイムを確立する**
  - 「何を固定し、何を動的にすべきか」の判断基準を明らかにする
  - 設計判断の経緯と論理を体系化する
- **副次的目的：**
  - Widget-to-Widget Reactivityによる動的生成の必要性を実証
  - ドメイン特化によるトークン削減効果を検証

### 1.5 研究の貢献
1. **設計パラダイムの提示**：ドメイン特化型動的UIシステムにおいて、何を固定し何を動的にすべきかの判断基準
2. **Widget-to-Widget Reactivityの提案**：同一画面上でのWidget間連動を動的生成する手法
3. **思考整理アプリでの実証**：提案手法の有効性を具体的なドメインで検証

---

## 2. Related Work

### 2.1 LLMによるUI生成
- **Jelly** [引用]
  - GeneralなLLM-Hardened DSLによる動的UI生成
  - OODM + DpG + DSLの3層アーキテクチャ
  - Item-to-Itemのリアクティビティ
  - **本研究との差異：** General vs Domain-Specific、Item vs Widget単位
- **その他のLLM UI生成研究**（要追加調査）
  - 比較軸：動的生成の粒度、ドメイン特化の有無、ユーザー入力の必要性

### 2.2 LLM-Hardened DSL
- 概念：LLMの出力自由度を制限することで品質を担保
- 宣言型（JSON）vs 手続き型
  - 従来的なUIフレームワークの分類と発想が共通
- 本研究の位置づけ：宣言型DSLをドメイン特化させる

### 2.3 思考整理支援ツール
- マインドマップツール（MindMeister, XMind等）
- タスク管理アプリ（Todoist, Notion等）
- 思考整理専用ツール（Miro, FigJam等）
- **共通の限界：** 固定UIであり、ユーザーの悩みに適応しない
- 本研究の位置づけ：悩みに応じてUIフロー全体を動的生成

---

## 3. Proposed Method

### 3.1 問題提起：GeneralなシステムをDomain-Specificに導入する際の課題

#### 3.1.1 Jellyの特性と限界
- JellyはSiri/Google Assistantに近い「何でもコンシェルジュ」
- 用途が決められないため、単純な部品の組み合わせを無限に扱う必要がある
- そのためDSLの規則が複雑になり、トークンコストが高い

#### 3.1.2 ドメイン特化の必要性
- 特定ドメインでこのシステムを使用する場合、ただ導入すれば良いわけではない
- **核心的な問い：固定UIで良いところと動的にすべきところをどう見極めるか？**

### 3.2 動的UI度ステージ：どこまで動的にすべきか

#### 3.2.1 6段階の定義（Stage 0-5）

| Stage | 動的要素 | UI部品 | DSLシステムの必要性 |
|-------|---------|--------|-------------------|
| 0 | なし | 固定UI | 不要 |
| 1 | コンテンツ（アルゴリズミック） | 固定UI | 不要 |
| 2 | コンテンツ（LLM） | 固定UI | 不要 |
| 3 | Widget選択 + コンテンツカスタマイズ | Widget | 不要 |
| **4** | **Widget間インタラクション定義** | **Widget** | **必要** |
| 5 | Widget構造自体（Atomから構築） | Atom | 必要 |

#### 3.2.2 Stage 3はオーバーエンジニアリングである

**論点：Stage 3のためにDSLシステムを導入する価値はない**

1. Stage 3の定義：「LLMがWidgetを選択し、コンテンツをカスタマイズする」
2. しかしこれはStage 2（固定UI + LLMコンテンツ生成）との差分が不明瞭
3. Widget選択はJSON出力で十分実現可能
4. コンテンツカスタマイズも各Widgetにデータを渡すだけ
5. **結論：** DSLで依存関係グラフを定義するシステムは、Stage 3には過剰である

#### 3.2.3 本研究はStage 4を採用する

**論点：Stage 4でこそDSLシステムの価値が正当化される**

1. Stage 4の定義：「LLMがWidget間のインタラクション（連動ルール）を動的に定義する」
2. Stage 3との決定的な違い：**「見た目」だけでなく「動作」をLLMが生成する**
3. 連動パターンは文脈依存であり、事前に全パターンを定義することは非現実的
4. **結論：** ここでDSLシステムを導入する価値がある

**具体例：優先度評価UI**

> Stage 3では、LLMは「優先度スライダーを使う」「項目はA, B, Cである」という選択とコンテンツを生成する。これは固定UIにデータを渡すだけで実現可能である。
>
> Stage 4では、LLMはさらに「ユーザーが緊急度・重要度・工数のスライダーを操作すると、その重み付けに基づいてランキングがリアルタイムに更新される」という連動ルール自体を生成する。どの軸をどう組み合わせてランキングに反映するかは、ユーザーの悩みの文脈によって異なるため、事前に全パターンを定義することは非現実的である。

**具体例：依存関係マッピング**

> Stage 3では、LLMは「依存関係図を使う」「ノードは仕事・健康・家族である」と生成する。
>
> Stage 4では、LLMは「ユーザーがノード間を接続すると、最も影響が大きい経路（クリティカルパス）が右側に自動でハイライトされる」という連動ルールを生成する。何をクリティカルパスとみなすかは、ユーザーの問題構造によって異なる。

#### 3.2.4 Stage 5を採用しない理由

1. Atomから組み上げるとLLMが毎回最適なUXを生成できるとは限らない
2. ドメイン特化ならWidgetを事前定義してUX品質を担保できる
3. トークンコストも増大する

#### 3.2.5 独立軸として扱う要素

| 軸 | 本研究の選択 | 理由 |
|---|-------------|------|
| スタイル/見た目 | 固定 | エンゲージメント向上は別目的の研究（Future Work） |
| 配置/レイアウト | 半固定 | 思考整理では視線誘導より内容が重要 |

### 3.3 システムアーキテクチャ：Widget方式の採用

#### 3.3.1 Jellyからの継承：3層アーキテクチャ
```
Layer 1: Object-Oriented Data Model (OODM)
  - セッション全体で扱うデータ構造を定義
  
Layer 2: Dependency Graph (DpG)
  - データ間の依存関係を定義
  
Layer 3: UI Specification (DSL)
  - 具体的なUI要素を定義
```

#### 3.3.2 Widgetとは何か
- **定義：** 特定の思考整理タスクを支援するための、事前定義されたUI部品
- **Jellyとの違い：**
  - Jelly：Atom（原子部品）からUIを動的に組み上げる（Stage 5相当）
  - 本研究：Widget（複合部品）を事前定義し、選択・組み合わせ・連動を動的に行う（Stage 4）

#### 3.3.3 Widget方式を採用する理由
1. **UX品質の担保**：各Widgetは事前にUXを設計・検証済み
2. **トークン削減**：Widgetの内部構造をLLMに説明する必要がない
3. **ドメイン知識の埋め込み**：思考整理に有効なUIパターンをWidgetとして事前定義

#### 3.3.4 ドメイン特化による変更点

| 層 | Jelly（General） | 本研究（Domain-Specific） |
|----|-----------------|-------------------------|
| OODM | 任意のデータ構造 | 思考整理特化のデータ型を事前定義 |
| DpG | Item-to-Item | Widget-to-Widget |
| DSL | Atomから組み上げ | 事前定義Widgetから選択 |

### 3.4 Widget-to-Widget Reactivity

#### 3.4.1 定義
- 同一画面上に複数のWidgetを配置
- ユーザーが一方を操作すると、他方がリアルタイムに更新
- **LLMは介在せず**、DpGで定義された依存関係に基づいて機械的に連動

#### 3.4.2 研究における役割

**「JSONで選択結果を出せば十分」への反論：**
- Widget選択だけならJSON出力で実現可能
- しかしWidget間の連動関係は文脈依存で動的に決まる
- この連動関係の定義こそがDSLシステムの価値

**「固定UIでいい」への反論：**
- 固定UIでは連動パターンも固定される
- ユーザーの悩みに応じて最適な連動パターンは異なる
- 全パターンを事前定義するのは非現実的

#### 3.4.3 Jellyとの差異

| 観点 | Jelly | 本研究 |
|------|-------|--------|
| 連動単位 | Item（データ項目） | Widget（UI部品） |
| 連動タイミング | 画面遷移時 | 同一画面上でリアルタイム |
| 定義方法 | DpGで動的生成 | DpGで動的生成（継承） |

#### 3.4.4 Reactivityの種類
- **data_input**: 前Widgetの出力を次Widgetの入力データとして使用
- **config_input**: 前Widgetの出力を次Widgetの設定（ラベル等）に反映
- **reactive_binding**: 同一画面上でのリアルタイム連動

### 3.5 設計空間の整理：何を固定し、何を動的にするか

#### 3.5.1 判断結果

| 要素 | 固定/動的 | 理由 |
|------|----------|------|
| Widget種類 | 固定 | UX品質担保、トークン削減 |
| フロー構造 | 半固定 | ドメイン知識（発散→整理→収束） |
| Widget選択 | 動的 | ユーザーの悩みに適応 |
| Widget順序 | 動的 | ボトルネックに応じた最適化 |
| Widgetコンテンツ | 動的 | ラベル・プロンプトの文脈適応 |
| Widget間連動 | 動的 | Widget-to-Widget Reactivity |
| スタイル/見た目 | 固定 | 本研究の範囲外 |
| 配置/レイアウト | 半固定 | パターンから選択 |

#### 3.5.2 判断基準の体系化

**固定すべき要素の基準：**
- ドメイン知識として事前に定義可能
- 固定することでLLMの判断負荷が軽減される
- UX品質を事前に担保できる

**動的にすべき要素の基準：**
- ユーザー入力に依存して変化する
- 固定すると「固定UIでいい」反論に勝てない
- 動的生成によりユーザー体験が向上する

### 3.6 生成パイプライン

```
Capture Data（ユーザー入力）
    ↓
LLM: ボトルネック診断
    ↓
LLM: OODM + DpG生成（Widget選択・連動定義を含む）
    ↓
LLM: DSL生成（Widgetコンテンツのカスタマイズ）
    ↓
Renderer: UI描画
    ↓
ユーザー操作 → Reactive更新（LLM不介在）
```

---

## 4. Implementation

### 4.1 思考整理支援アプリの概要

#### 4.1.1 なぜ思考整理を題材としたか
- 悩みの内容・状況・ユーザー背景が多様
- 状況に応じて刻々と変化する
- ユーザーの認知思考特性が多岐に渡る
- 固定UIでは対応困難、ユーザー自身のカスタマイズも困難
- → ドメイン特化型動的UI生成の価値を実証しやすい

#### 4.1.2 アプリ構成
```
Capture Phase: 悩みの入力・タグ付け・問診
    ↓
Plan Phase: 思考整理（本研究の主対象）
    ↓
Breakdown Phase: タスク分解（簡易実装）
```

### 4.2 Plan Phaseの設計

#### 4.2.1 3ステージ構造（半固定のフロー構造）
1. **発散・探索 (Diverge)**: 可能性を広げ、選択肢を増やす
2. **整理・評価 (Organize)**: 選択肢を構造化し、関係性を把握
3. **収束・決定 (Converge)**: 優先順位をつけ、方針を確定
4. **まとめ (Summary)**: 構造化文章で確認・修正

#### 4.2.2 ボトルネック診断
- LLMがCapture情報から思考の障壁を診断
- 8種類のボトルネックタイプ：
  1. 選択肢が多すぎる
  2. 何から考えればいいか分からない
  3. 複数の問題が絡んでいる
  4. 感情的ブロック
  5. 情報不足
  6. 決断への恐れ
  7. 視点固定
  8. 優先順位がつけられない

### 4.3 Widgetライブラリ
（実装詳細は別途記述）

### 4.4 Widget-to-Widget Reactivityの実装例
（実装詳細は別途記述）

### 4.5 DSL仕様
（実装詳細は別途記述）

---

## 5. Evaluation

### 5.1 評価の目的と構成
- **RQ1**: Widget-to-Widget Reactivityは適切に生成されるか？
- **RQ2**: 生成されるUIフローは思考整理に適切か？
- **RQ3**: Widget種類数とコンテキストウィンドウのトレードオフはどうか？
- **RQ4**: LLMモデルの違いは生成品質にどう影響するか？

### 5.2 実験1: 技術性能評価

#### 5.2.1 トークン使用量
- 測定項目：OODM生成、DSL生成、合計
- Widget数を変化させた場合の影響

#### 5.2.2 生成成功率
- 構文エラー率
- 実行エラー率
- Reactivity定義の妥当性

#### 5.2.3 レスポンス時間
- 各生成ステップの時間
- 総レスポンス時間

### 5.3 実験2: Widget数とコンテキストウィンドウのトレードオフ

#### 5.3.1 実験設計
- Widget数を変化させる（6個 / 9個 / 12個 / 15個）
- 各条件での生成品質を比較

#### 5.3.2 評価項目
- プロンプト長（トークン数）
- 生成成功率
- Widget選択の適切性

### 5.4 実験3: モデル比較

#### 5.4.1 検証したい仮説
1. 構造化出力ではCodexが優位か
2. miniはどのタスクまで耐えられるか
3. 「診断・選択は賢いモデル、構造化は軽いモデル」は実用的か

#### 5.4.2 タスクの分類

| タスク | 内容 | 特性 |
|--------|------|------|
| 診断 | ボトルネック診断 | 推論・分析 |
| 選択 | Widget選択 | 要件定義的・マッチング |
| OODM/DpG/DSL | 構造化出力 | 構文の正確性 |
| まとめ | 文章生成 | 要約・自然言語 |

#### 5.4.3 検証パターン

| パターン | 診断 | 選択 | OODM/DpG/DSL | まとめ | 狙い |
|---------|------|------|--------------|--------|------|
| A: 全部汎用 | GPT-5 | GPT-5 | GPT-5 | GPT-5 | 品質上限（ベースライン） |
| B: 全部mini | mini | mini | mini | mini | コスト下限・mini耐性 |
| C: 構造化Codex | GPT-5 | GPT-5 | Codex | GPT-5 | Codex優位性検証 |
| D: 構造化mini | GPT-5 | GPT-5 | mini | GPT-5 | 構造化でのmini耐性 |

#### 5.4.4 評価指標
- 構文エラー率（自動検証）
- 生成適切性（専門家評価）
- レスポンス時間
- 総コスト

### 5.5 実験4: 専門家評価（10ケース）

#### 5.5.1 サンプルケース設計
- 8種類のボトルネックを網羅
- Reactivity活用ケースを5件含む
- 複雑度のバリエーション

#### 5.5.2 評価項目
- ボトルネック診断の適切性
- Widget選択の適切性
- フロー構成の論理性
- Widget-to-Widget Reactivityの有効性
- Widgetコンテンツのカスタマイズ適合性
- 総合評価

### 5.6 実験5: ユーザー検証（5名）

#### 5.6.1 目的
- 技術的側面を重視（動的UIシステムの評価）
- 実用性の示唆を得る

#### 5.6.2 評価項目
- UI適合度
- 思考整理効果の実感
- UI遷移の自然さ
- Reactivityの認識度

### 5.7 結果（予定）

#### 5.7.1 RQ1: Reactivity生成
- 構文エラー率
- 専門家評価（意味的妥当性）
- 有効だったReactivityパターンの分析

#### 5.7.2 RQ2: UIフロー適切性
- 専門家評価平均
- ユーザー満足度平均
- ボトルネックタイプ別の傾向

#### 5.7.3 RQ3: Widget数トレードオフ
- 最適なWidget数の範囲
- コンテキストウィンドウ逼迫の閾値

#### 5.7.4 RQ4: モデル比較
- 各モデルの得意・不得意
- 役割分担パターンの実用性
- コスト・品質・速度のバランス

---

## 6. Discussion

### 6.1 設計パラダイムの妥当性

#### 6.1.1 Stage 4の選択は適切だったか
- Stage 3（オーバーエンジニアリング）を避けた効果
- Stage 5（UX品質担保困難）を避けた効果

#### 6.1.2 固定と動的の判断は適切だったか
- トークン削減効果からの検証
- 生成品質からの検証
- ユーザー体験からの検証

#### 6.1.3 他ドメインへの適用可能性
- 本パラダイムの一般化可能な部分
- ドメイン固有の調整が必要な部分

### 6.2 Widget-to-Widget Reactivityの効果

#### 6.2.1 「JSONで選択結果を出せば十分」への回答
- Reactivityにより実現できた価値
- 動的定義の必要性の実証

#### 6.2.2 「固定UIでいい」への回答
- 固定UIでは得られない体験
- 文脈依存の連動パターンの有効性

#### 6.2.3 Reactivityパターンの類型化
- 有効だったパターン
- うまくいかなかったパターン

### 6.3 Widget数のトレードオフに関する知見

#### 6.3.1 発見された閾値・傾向
- コンテキストウィンドウ逼迫が発生する条件
- 機能性と生成品質のバランスポイント

### 6.4 モデル選択に関する知見

#### 6.4.1 タスク別の推奨モデル
- 診断・選択タスク
- 構造化出力タスク
- まとめタスク

#### 6.4.2 役割分担の実用性
- コスト削減効果
- 品質への影響

### 6.5 制約と限界

#### 6.5.1 技術的制約
- LLMの生成品質への依存
- レスポンス時間
- コスト

#### 6.5.2 評価の限界
- サンプルサイズ
- 短期的な評価

---

## 7. Future Work

### 7.1 タスク実行フェーズの実装
- Breakdownで生成されたタスクの実行支援
- アプリを開くたびにUIを動的生成

### 7.2 Context-Aware強化
- デバイス情報の活用（曜日、時刻、空き時間、現在地、画面サイズ）
- 状況に応じたUI最適化

### 7.3 ローカルLLM / オンデバイス生成
- ネットワーク非依存
- プライバシー配慮が必要なタスクへの対応
- スマートフォン上での生成

### 7.4 スタイル/見た目の動的生成
- エンゲージメント向上を目的とした研究
- 視覚的なカスタマイズ

### 7.5 他ドメインへの適用
- 設計パラダイムの一般化
- 異なるドメインでの検証

---

## 8. Conclusion

- ドメイン特化型LLM動的UI生成の設計パラダイムを提示した
- 動的UI度の6段階（Stage 0-5）を整理し、Stage 4（Widget間インタラクションの動的定義）が本研究に適切であることを示した
- Stage 3は「オーバーエンジニアリング」であり、Stage 4でこそDSLシステムの価値が正当化されることを論じた
- 「何を固定し、何を動的にすべきか」の判断基準を体系化した
- Widget-to-Widget Reactivityにより、「JSONで十分」「固定UIでいい」という反論に対する回答を実証した
- 思考整理支援アプリを題材に、提案手法の有効性を検証した
- Widget数とコンテキストウィンドウのトレードオフ、モデル比較など、実践的な知見を得た
- 本パラダイムは他のドメイン特化型動的UIシステムの設計にも適用可能である

---

## 付録

### A. Widgetカタログ（12種類の詳細仕様）
### B. DSL完全仕様
### C. 専門家評価シート
### D. ユーザー検証プロトコル
### E. 評価ケース詳細（10ケース）
### F. モデル比較詳細データ

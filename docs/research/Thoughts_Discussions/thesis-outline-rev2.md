# 卒業論文アウトライン
## LLM-Hardened DSLによるドメイン特化型LLMリアルタイムUI生成システムの設計パラダイム ― 思考整理支援アプリケーションを題材として

---

## 1. Introduction

### 1.1 背景：UIの柔軟化への要求
- コンピュータの普遍化により、現代のアプリケーションには複雑な責務と多様な要望が求められる
- アプリは特定のユースケースに最適化することで「使いやすく」なる
- しかし、要望が多岐に渡ると機能/UIを全員に最適化することには限度がある
- **問い：LLMでUIを動的生成すれば解決できるのでは？**

### 1.2 背景：LLMによるリアルタイムUI生成の登場
- LLMによるコーディングの発展（コード補完→自然言語変換→自律エージェント）
- 開発段階ではプログラマが介在するため、LLMの不完全さを補完できる
- しかし、リアルタイム生成では専門家が介在しない（LLM→利用者）
- **課題：LLMの不安定さ（再現性、誤り）をどう制御するか？**

### 1.3 既存研究：LLM-Hardened DSLによる解決
- LLM-Hardened DSL：LLMが扱いやすいDSLを定義し、出力の自由度を制限する手法
- Jellyの成果：GeneralなDSLで柔軟なUI生成を実現
- **残された課題：**
  1. GeneralなDSLはトークンコストが高い
  2. プロンプトが長くなり生成品質が希釈される
  3. ユーザーが継続的にプロンプトを与える必要がある

### 1.4 研究目的
- **主目的：ドメイン特化型LLM動的UI生成の設計パラダイムを確立する**
  - 「何を固定し、何を動的にすべきか」の判断基準を明らかにする
  - 設計判断の経緯と論理を体系化する
- **副次的目的：**
  - Widget-to-Widget Reactivityによる動的生成の必要性を実証
  - ドメイン特化によるトークン削減効果を検証

### 1.5 研究の貢献
1. **設計パラダイムの提示**：ドメイン特化型動的UIシステムにおいて、何を固定し何を動的にすべきかの判断基準
2. **Widget-to-Widget Reactivityの提案**：同一画面上でのWidget間連動を動的生成する手法
3. **思考整理アプリでの実証**：提案手法の有効性を具体的なドメインで検証

---

## 2. Related Work

### 2.1 LLMによるUI生成
- **Jelly** [引用]
  - GeneralなLLM-Hardened DSLによる動的UI生成
  - OODM + DpG + DSLの3層アーキテクチャ
  - Item-to-Itemのリアクティビティ
  - **本研究との差異：** General vs Domain-Specific、Item vs Widget単位
- **その他のLLM UI生成研究**（要追加調査）
  - 比較軸：動的生成の粒度、ドメイン特化の有無、ユーザー入力の必要性

### 2.2 LLM-Hardened DSL
- 概念：LLMの出力自由度を制限することで品質を担保
- 宣言型（JSON）vs 手続き型
  - 従来的なUIフレームワークの分類と発想が共通
- 本研究の位置づけ：宣言型DSLをドメイン特化させる

### 2.3 思考整理支援ツール
- マインドマップツール（MindMeister, XMind等）
- タスク管理アプリ（Todoist, Notion等）
- 思考整理専用ツール（Miro, FigJam等）
- **共通の限界：** 固定UIであり、ユーザーの悩みに適応しない
- 本研究の位置づけ：悩みに応じてUIフロー全体を動的生成

---

## 3. Proposed Method

### 3.1 問題提起：GeneralなシステムをDomain-Specificに導入する際の課題

#### 3.1.1 Jellyの特性と限界
- JellyはSiri/Google Assistantに近い「何でもコンシェルジュ」
- 用途が決められないため、単純な部品の組み合わせを無限に扱う必要がある
- そのためDSLの規則が複雑になり、トークンコストが高い

#### 3.1.2 ドメイン特化の必要性
- 特定ドメインでこのシステムを使用する場合、ただ導入すれば良いわけではない
- **核心的な問い：固定UIで良いところと動的にすべきところをどう見極めるか？**

### 3.2 設計パラダイム：動的UI度の段階的選択

#### 3.2.1 動的UI度ステージ
ドメイン特化システムにおいて、UIの動的生成をどの程度行うかには段階がある：

| Stage | 説明 | LLMの責務 |
|-------|------|----------|
| **1** | 固定UI + アルゴリズミックなコンテンツ | なし |
| **2** | 固定UI + コンテンツのLLM生成 | コンテンツ生成のみ |
| **3** | LLMがWidget選択 + 任意のコンテンツ割り当て | Widget選択 |
| **4** | LLMがWidget組み合わせ選択 + 配置決定 | 選択 + 配置 |
| **5** | LLMがWidget組み合わせ選択 + 相互インタラクション定義 | 選択 + 連動定義 |
| **6** | LLMがAtom（原子部品）からWidgetを組み上げる | 完全動的構築 |

#### 3.2.2 各ステージの評価
- **Stage 1-2**：「動的UI生成」と呼ぶには不十分。従来のアプリと本質的に変わらない
- **Stage 3**：Widget選択のみ。JSONで選択結果を出力すれば十分では？という反論が成立
- **Stage 4-6**：動的UI生成システムを導入する価値がある

#### 3.2.3 Stage 6の問題点
- 導入の動機としては最も強い（最大の柔軟性）
- しかし、LLMが毎回最適なUXを生成できるとは限らない
- UXを考慮するなら、Widgetを事前定義（pre-define）した方が良い
- **特定ドメイン向けならこれが可能**

#### 3.2.4 本研究の選択：Stage 5
- **配置（Stage 4）を重要視しない理由：**
  - 配置が重要なのはエンゲージメント維持、ダッシュボードなど視線誘導が必要な場合
  - 思考整理では上から順番に見てもらえれば問題ない
- **相互インタラクション（Stage 5）に焦点を絞る理由：**
  - Widget選択だけなら「JSONで十分」の反論に勝てない
  - Widget間の連動を動的に定義することで、動的生成の価値を実証できる

### 3.3 システムアーキテクチャ：Widget方式の採用

#### 3.3.1 Jellyからの継承：3層アーキテクチャ
```
Layer 1: Object-Oriented Data Model (OODM)
  - セッション全体で扱うデータ構造を定義
  
Layer 2: Dependency Graph (DpG)
  - データ間の依存関係を定義
  
Layer 3: UI Specification (DSL)
  - 具体的なUI要素を定義
```

#### 3.3.2 Widgetとは何か
- **定義：** 特定の思考整理タスクを支援するための、事前定義されたUI部品
- **Jellyとの違い：**
  - Jelly：Atom（原子部品）からUIを動的に組み上げる（Stage 6相当）
  - 本研究：Widget（複合部品）を事前定義し、選択・組み合わせを動的に行う（Stage 5）

#### 3.3.3 Widget方式を採用する理由
1. **UX品質の担保**
   - 各Widgetは事前にUXを設計・検証済み
   - LLMが毎回ゼロからUXを考える必要がない
2. **トークン削減**
   - Widgetの内部構造をLLMに説明する必要がない
   - 選択肢として提示するだけで良い
3. **ドメイン知識の埋め込み**
   - 思考整理に有効なUIパターンをWidgetとして事前定義
   - LLMはドメイン知識を活用できる

#### 3.3.4 ドメイン特化による変更点
| 層 | Jelly（General） | 本研究（Domain-Specific） |
|----|-----------------|-------------------------|
| OODM | 任意のデータ構造 | 思考整理特化のデータ型を事前定義 |
| DpG | Item-to-Item | Widget-to-Widget |
| DSL | Atomから組み上げ | 事前定義Widgetから選択 |

### 3.4 Widget-to-Widget Reactivity

#### 3.4.1 概念
- 同一画面上に複数のWidgetを配置
- ユーザーが一方を操作すると、他方がリアルタイムに更新
- **LLMは介在せず**、DpGで定義された依存関係に基づいて機械的に連動

#### 3.4.2 なぜWidget-to-Widget Reactivityが必要か
- **「JSONで選択結果を出せば十分」への反論：**
  - Widget選択だけなら確かにJSON出力で実現可能
  - しかし、Widget間の連動関係は文脈依存で動的に決まる
  - この連動関係の定義こそが、動的UI生成システムを導入する価値
- **「固定UIでいい」への反論：**
  - 固定UIでは連動パターンも固定される
  - ユーザーの悩みに応じて最適な連動パターンは異なる

#### 3.4.3 Jellyとの差異
| 観点 | Jelly | 本研究 |
|------|-------|--------|
| 連動単位 | Item（データ項目） | Widget（UI部品） |
| 連動タイミング | 画面遷移時 | 同一画面上でリアルタイム |
| 定義方法 | DpGで動的生成 | DpGで動的生成（継承） |

#### 3.4.4 Reactivityの定義方式
- DpGにおいてWidget間の依存関係を記述
- 依存の種類：
  - **data_input**: 前Widgetの出力を次Widgetの入力データとして使用
  - **config_input**: 前Widgetの出力を次Widgetの設定（ラベル等）に反映
  - **reactive_binding**: 同一画面上でのリアルタイム連動

### 3.5 設計空間の整理：何を固定し、何を動的にするか

#### 3.5.1 判断結果
| 要素 | 固定/動的 | 理由 |
|------|----------|------|
| Widget種類 | 固定 | UX品質担保、トークン削減 |
| フロー構造 | 半固定 | ドメイン知識（発散→整理→収束） |
| Widget選択 | 動的 | ユーザーの悩みに適応 |
| Widget順序 | 動的 | ボトルネックに応じた最適化 |
| Widget設定 | 動的 | ラベル・プロンプトの文脈適応 |
| Widget間連動 | 動的 | Widget-to-Widget Reactivity |

#### 3.5.2 判断基準の体系化
- **固定すべき要素の基準：**
  - ドメイン知識として事前に定義可能
  - 固定することでLLMの判断負荷が軽減される
  - UX品質を事前に担保できる
- **動的にすべき要素の基準：**
  - ユーザー入力に依存して変化する
  - 固定すると「固定UIでいい」反論に勝てない
  - 動的生成によりユーザー体験が向上する

### 3.6 生成パイプライン

```
Capture Data（ユーザー入力）
    ↓
LLM: ボトルネック診断
    ↓
LLM: OODM + DpG生成（Widget選択・連動定義を含む）
    ↓
LLM: DSL生成（Widget設定のカスタマイズ）
    ↓
Renderer: UI描画
    ↓
ユーザー操作 → Reactive更新（LLM不介在）
```

---

## 4. Implementation

### 4.1 思考整理支援アプリの概要

#### 4.1.1 なぜ思考整理を題材としたか
- 悩みの内容・状況・ユーザー背景が多様
- 状況に応じて刻々と変化する
- ユーザーの認知思考特性が多岐に渡る
- 固定UIでは対応困難、ユーザー自身のカスタマイズも困難
- → ドメイン特化型動的UI生成の価値を実証しやすい

#### 4.1.2 アプリ構成
```
Capture Phase: 悩みの入力・タグ付け・問診
    ↓
Plan Phase: 思考整理（本研究の主対象）
    ↓
Breakdown Phase: タスク分解（簡易実装）
```

### 4.2 Plan Phaseの設計

#### 4.2.1 3ステージ構造（半固定のフロー構造）
1. **発散・探索 (Diverge)**: 可能性を広げ、選択肢を増やす
2. **整理・評価 (Organize)**: 選択肢を構造化し、関係性を把握
3. **収束・決定 (Converge)**: 優先順位をつけ、方針を確定
4. **まとめ (Summary)**: 構造化文章で確認・修正

#### 4.2.2 ボトルネック診断
- LLMがCapture情報から思考の障壁を診断
- 8種類のボトルネックタイプ：
  1. 選択肢が多すぎる
  2. 何から考えればいいか分からない
  3. 複数の問題が絡んでいる
  4. 感情的ブロック
  5. 情報不足
  6. 決断への恐れ
  7. 視点固定
  8. 優先順位がつけられない

### 4.3 Widgetライブラリ

#### 4.3.1 メタデータ設計
- **timing**: 0.0（序盤）～1.0（終盤）の推奨タイミング
- **versatility**: 汎用性スコア（高→様々な場面で使用可能）
- **対応ボトルネック**: どの思考障壁に有効か

#### 4.3.2 Widget一覧（12種類）
**Stage 1（発散）:**
- ブレインストームカード
- 感情カラーパレット
- 質問カード連鎖（Widget内LLM活用）
- マインドマップ生成
- アナロジー選択UI

**Stage 2（整理）:**
- 時間軸スライダー
- ペルソナ視点切替
- カード仕分けUI
- 依存関係マッピング（Reactivity活用）

**Stage 3（収束）:**
- マトリックスUI
- 優先度スライダーグリッド（Reactivity活用）
- トレードオフ天秤（Reactivity活用）

**まとめ:**
- 構造化文章まとめ

### 4.4 Widget-to-Widget Reactivityの実装例

#### 例1: 優先度スライダー → ランキング表示
```
[左側] 複数軸スライダー
  - 緊急度: ●━━━━━━━━━
  - 重要度: ━━━━━●━━━━
  - 工数:   ━━━━━━━●━━
       ↓ リアルタイム連動（LLM不介在）
[右側] 優先順位ランキング
  1. プロジェクトA（スコア: 78）
  2. プロジェクトB（スコア: 65）
  3. プロジェクトC（スコア: 52）
```

#### 例2: トレードオフ天秤
```
[左側] リスク要因リスト（重み調整可能）
  - 評価低下リスク: ●━━━━━
  - 時間不足リスク: ━━━●━━
       ↓ リアルタイム連動（LLM不介在）
[右側] 天秤ビジュアライゼーション
  リスク ⚖️ リターン
  [40%]     [60%]
```

### 4.5 DSL仕様
（実装詳細は別途記述）

---

## 5. Evaluation

### 5.1 評価の目的と構成
- **RQ1**: Widget-to-Widget Reactivityは適切に生成されるか？
- **RQ2**: 生成されるUIフローは思考整理に適切か？
- **RQ3**: Widget種類数とコンテキストウィンドウのトレードオフはどうか？
- **RQ4**: LLMモデルの違いは生成品質にどう影響するか？

### 5.2 実験1: 技術性能評価

#### 5.2.1 トークン使用量
- 測定項目：OODM生成、DSL生成、合計
- Widget数を変化させた場合の影響

#### 5.2.2 生成成功率
- 構文エラー率
- 実行エラー率
- Reactivity定義の妥当性

#### 5.2.3 レスポンス時間
- OODM生成時間
- DSL生成時間
- UI描画時間

### 5.3 実験2: Widget数とコンテキストウィンドウのトレードオフ

#### 5.3.1 実験設計
- Widget数を変化させる（6個 / 9個 / 12個 / 15個）
- 各条件での生成品質を比較

#### 5.3.2 評価項目
- プロンプト長（トークン数）
- 生成成功率
- Widget選択の適切性
- 応答時間

#### 5.3.3 期待される知見
- Widget数の増加に伴うコンテキストウィンドウ逼迫の影響
- 機能性と生成品質のバランスポイント

### 5.4 実験3: モデル比較

#### 5.4.1 比較対象
- 汎用LLM（Claude Sonnet, GPT-4o等）
- コーディング特化LLM（Claude Sonnet with coding prompt等）
- 低遅延の小規模LLM（Claude Haiku, GPT-4o-mini等）

#### 5.4.2 評価項目
- 生成成功率
- 生成品質（専門家評価）
- レスポンス時間
- コスト

### 5.5 実験4: 専門家評価（10ケース）

#### 5.5.1 サンプルケース設計
- 8種類のボトルネックを網羅
- Reactivity活用ケースを5件含む
- 複雑度のバリエーション

#### 5.5.2 評価項目
- ボトルネック診断の適切性
- Widget選択の適切性
- フロー構成の論理性
- Widget-to-Widget Reactivityの有効性
- Widget設定のカスタマイズ適合性
- 総合評価

### 5.6 実験5: ユーザー検証（5名）

#### 5.6.1 実験プロトコル
- 各参加者2-3セッション
- 事前・事後アンケート
- 半構造化インタビュー

#### 5.6.2 収集データ
- 操作ログ（各Widgetでの操作時間、選択変更回数）
- アンケート回答
- インタビュー内容

#### 5.6.3 評価項目
- UI適合度
- 思考整理効果の実感
- UI遷移の自然さ
- Reactivityの認識度

### 5.7 結果（予定）

#### 5.7.1 RQ1: Reactivity生成
- 構文エラー率：X%
- 専門家評価（意味的妥当性）：X.X/5
- 有効だったReactivityパターンの分析

#### 5.7.2 RQ2: UIフロー適切性
- 専門家評価平均：X.X/5
- ユーザー満足度平均：X.X/5
- ボトルネックタイプ別の傾向

#### 5.7.3 RQ3: Widget数トレードオフ
- 最適なWidget数の範囲
- コンテキストウィンドウ逼迫の閾値

#### 5.7.4 RQ4: モデル比較
- 各モデルの適性
- コスト・品質・速度のバランス

---

## 6. Discussion

### 6.1 設計パラダイムの妥当性

#### 6.1.1 動的UI度Stage 5の選択は適切だったか
- Stage 4（配置）を省略した影響
- Stage 6（Atom組み上げ）を避けた効果

#### 6.1.2 固定と動的の判断は適切だったか
- トークン削減効果からの検証
- 生成品質からの検証
- ユーザー体験からの検証

#### 6.1.3 他ドメインへの適用可能性
- 本パラダイムの一般化可能な部分
- ドメイン固有の調整が必要な部分

### 6.2 Widget-to-Widget Reactivityの効果

#### 6.2.1 「JSONで選択結果を出せば十分」への回答
- Reactivityにより実現できた価値
- 動的定義の必要性の実証

#### 6.2.2 「固定UIでいい」への回答
- 固定UIでは得られない体験
- 文脈依存の連動パターンの有効性

#### 6.2.3 Reactivityパターンの類型化
- 有効だったパターン
- うまくいかなかったパターン

### 6.3 Widget数のトレードオフに関する知見

#### 6.3.1 発見された閾値・傾向
- コンテキストウィンドウ逼迫が発生する条件
- 機能性と生成品質のバランスポイント

#### 6.3.2 実務への示唆
- ドメイン特化システム設計時のWidget数の指針

### 6.4 モデル選択に関する知見

#### 6.4.1 用途別の推奨モデル
- 品質重視の場合
- 速度重視の場合
- コスト重視の場合

### 6.5 制約と限界

#### 6.5.1 技術的制約
- LLMの生成品質への依存
- レスポンス時間
- コスト

#### 6.5.2 評価の限界
- サンプルサイズ
- 短期的な評価

### 6.6 設計判断の振り返り

#### 6.6.1 うまくいった判断
- 3ステージ構造
- Widget数の限定
- Reactivityの導入

#### 6.6.2 改善の余地がある判断
- （評価結果に基づいて記述）

---

## 7. Future Work

### 7.1 タスク実行フェーズの実装
- Breakdownで生成されたタスクの実行支援
- アプリを開くたびにUIを動的生成

### 7.2 Context-Aware強化
- デバイス情報の活用（曜日、時刻、空き時間、現在地、画面サイズ）
- 状況に応じたUI最適化

### 7.3 ローカルLLM / オンデバイス生成
- ネットワーク非依存
- プライバシー配慮が必要なタスクへの対応
- スマートフォン上での生成

### 7.4 他ドメインへの適用
- 設計パラダイムの一般化
- 異なるドメインでの検証

---

## 8. Conclusion

- ドメイン特化型LLM動的UI生成の設計パラダイムを提示した
- 動的UI度の6段階を整理し、Stage 5（相互インタラクションの動的定義）が本研究に適切であることを示した
- 「何を固定し、何を動的にすべきか」の判断基準を体系化した
- Widget-to-Widget Reactivityにより、「JSONで十分」「固定UIでいい」という反論に対する回答を実証した
- 思考整理支援アプリを題材に、提案手法の有効性を検証した
- Widget数とコンテキストウィンドウのトレードオフ、モデル比較など、実践的な知見を得た
- 本パラダイムは他のドメイン特化型動的UIシステムの設計にも適用可能である

---

## 付録

### A. Widgetカタログ（12種類の詳細仕様）
### B. DSL完全仕様
### C. 専門家評価シート
### D. ユーザー検証プロトコル
### E. 評価ケース詳細（10ケース）
### F. モデル比較詳細データ

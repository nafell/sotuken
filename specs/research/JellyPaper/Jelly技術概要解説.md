# Jelly技術概要解説

*Exported on: 2025/10/11 20:01:59*

この論文で提案されている、生成可能で柔軟なユーザーインターフェース（Generative and Malleable User Interfaces: GMUI）を実現するためのプロトタイプシステム「**Jelly**」の実装パイプラインについて、エンジニア向けに深掘りして解説します。

このシステムの中核は、タスク駆動型データモデル（Task-Driven Data Model）を生成し、それを基盤としてUIを生成・進化させる点にあります。

### 1. システムの技術スタックと全体アーキテクチャ

Jellyのプロトタイプは、特定の技術スタックを用いて開発されています。

• **バックエンド/パイプライン:** **Python**

• **フロントエンド:** **JavaScript**と**Reactフレームワーク**

• **大規模言語モデル (LLM):** **AnthropicのClaude 3.5 Sonnet** および **OpenAIのGPT-4o**

このパイプラインは、ユーザーのプロンプトを受け取り、以下の主要なステップを経てUIを生成します。

1. **LLMベースのタスク分析:** ユーザーのプロンプトを解析し、目標とサブタスクを推論します。

2. **タスク駆動型データモデルの生成:** LLMがタスク構造を表すデータモデル（スキーマ、依存関係グラフ、構造化データ）を生成します。

3. **UI仕様の生成:** データモデルがUI仕様に変換されます。

4. **ルールベースのUIレンダリング:** 定義済みのルールに基づいてUI仕様がコンポーネントとしてレンダリングされます。

パフォーマンスを最適化するため、独立したLLMリクエストは**並行して処理される**設計となっています。また、生成ステップごとに**フューショットプロンプティング**を使用し、ユーザーの過去のリクエストをコンテキストとして組み込むことで、制御された正確なJSON形式の出力をLLMに指示します。

### 2. コアコンポーネント：タスク駆動型データモデルの構築（DG1）

GMUIの基盤となるのは、タスクの本質的な情報エンティティ、関係、およびデータ自体を構造化して表現するタスク駆動型データモデルです。このモデルは3つの主要コンポーネントで構成されます。

#### 2.1. オブジェクト指向関係スキーマ (Object-Relational Schema)

これは、タスクに必要なエンティティの型、その属性、およびエンティティ間の関係を記述します。

• **Taskオブジェクト:** スキーマのルートであり、タスク全体の必須属性（例：旅行計画における目的地、期間）を記述します。

• **Entity:** タスクの必須コンポーネントをモデル化します（例：食事計画におけるレシピ、食材、店舗）。

• **Attribute (属性型):** 属性には以下の4種類があります。

    ◦ **SVAL (Singular Data Value):** 単一のデータ値（例：日付、場所）。

    ◦ **DICT (Dictionary):** キーと値のペアを格納（例：料理の栄養成分表）。

    ◦ **PNTR (Pointer):** 別のエンティティへの参照（例：買い物アイテムにおける「店舗」への参照）。

    ◦ **ARRY (Array):** SVALまたはPNTR型のアイテムのコレクション（例：デイリーミールプランのリスト）。

    ◦ *(エンジニア注: DICTの配列はスキーマ構文で許可されていません。複数のエンティティが同じDICTを共有する場合、それはエンティティとして抽象化され、PNTRとして扱われます。これはデータモデルの簡素化と一貫性確保のためです)*。

#### 2.2. 依存関係グラフ (Dependency Graph)

複雑なタスクにおけるコンポーネント間の関係や制約を定義します。LLMがタスクの特性に基づいてこのグラフを生成します。

依存関係は以下の構造を持ちます。 $\text{Dependency} := {\text{Source}, \text{Target}, \text{Mechanism}, \text{Relationship}}$

• **Mechanism (動作):** ターゲットがソースの変更にどのように反応するかを定義します。

    ◦ **Validate (検証):** 制約が守られていることを確認します（例：チェックアウト日はチェックイン日より後であること）。違反があれば更新は拒否され、UIで問題がハイライトされます。

    ◦ **Update (更新):** 変更を自動的に伝播させます（例：食材の量が変更されたら、料理の総カロリーが自動更新される）。

• **Relationship (関係):** ソースとターゲットの関係を定義します。数値計算や検証など、コードで表現可能な場合は**JavaScriptスニペット**が生成されます。それ以外の場合は、LLMが効果を適用できるよう**自然言語**で記述されます。

    ◦ *(エンジニア注: 技術評価の結果、依存関係の精度は高いものの、ソースとターゲットが逆転するエラーやスキーマで既に宣言されている冗長な依存関係が見られたため、正確性を確保するための検証(Validation)がパイプラインに組み込まれています)*。

### 3. UI仕様の生成とレンダリング（DG2）

データモデルが生成された後、UIの整合性、安定性、および品質を保証するため、パイプラインは**仕様ベースのアプローチ**でUIを生成します。

#### 3.1. UIマッピングルールによるスキーマの注釈

パイプラインは、タスクおよびエンティティの各属性を検査し、それらのデータ型、機能的役割、レンダリングタイプを指定するラベルで注釈付けします。これらの注釈が、ルールベースのアプローチでスキーマ要素をUIコンポーネントにマッピングするための仕様となります。

主要な注釈要素とレンダリングへの影響は以下の通りです。

| 属性タイプ | 主要ラベル | 機能とレンダリング動作の例 |
|---|---|---|
| **SVAL** | `<function, render, editable>` | `start_date`が`<display, time, true>`とラベル付けされた場合、ユーザー編集可能なカレンダーウィジェットとしてレンダリングされます。 |
| **PNTR** | `<function, thumbnail, editable>` | 参照先エンティティのうち、縮小表示（サムネイル）として表示すべき属性を指定します（例：店舗エンティティへのポインタには、店舗の`name`のみをハイパーリンクとして表示）。 |
| **ARRY** | `<function, render, editable>` | `render`タイプは`expanded`（完全展開）または`summary`（要約表示）のいずれかです。`summary`はクリックで展開するボタンとして表示されます。 |

この仕様は、抽象モデルと具象UIコンポーネント間のマッピングを支援します。

#### 3.2. UIステート管理とレンダリング

生成された依存関係は、対応する**UIステート管理ルール**によって実行されます。

• **ステート管理ユニット**は、依存関係の実行をサンドボックス化し、UIの安定性を確保するために効果を限定します。

• 更新または検証メカニズムを解釈し、実行します。

• レンダリングプロセスは、タスク全体のオブジェクト指向関係スキーマから開始され、参照される各エンティティとその属性を**再帰的にレンダリング**します。マッピングは、モデルとデータの更新全体で一貫性を保証する**定義済みの一連のルール**によって処理されます。

### 4. モデルの進化とカスタマイズの実装（DG3）

Jellyの「柔軟性（Malleability）」は、ユーザーの継続的なプロンプトや直接操作が、動的にデータモデルに反映されることで実現されます。

#### 4.1. 継続的なプロンプトによる更新

ユーザーがフォローアップの要求をチャットビューで提供すると、システムはLLMにクエリを実行し、スキーマ（エンティティや属性の追加、削除、更新）またはデータへの必要な更新操作を決定します。

これらの要求は、以下の構造を持つ操作シーケンスに解析されます。 $\text{Updater} := {\text{Target}, \text{Action}, \text{Specifications}}$

• **Target:** 関連するエンティティまたは属性のパス。

• **Action:** `add`、`remove`、`update`（スキーマとデータの両方）、およびデータ固有の操作（`cluster`、`filter`、`sort`）が含まれます。

• **Specifications:** 特定の変更の詳細を記述します。

LLMはこの情報に基づき、UIを更新するために必要な操作を生成します。

#### 4.2. GUIベースのデータモデルカスタマイズ

自然言語での変更（プロンプティング）に加え、より細かなカスタマイズのためにGUIからの直接操作も可能です。

• **データ編集:** データの値は、適切なウィジェット表現（例：カレンダー、チェックボックス）を通じて直接編集可能です。

• **AI補完機能:** ユーザーがエンティティの一部属性のみを手動で入力し、残りの属性が不足している場合、システムは「AI補完/更新」機能（`🪄`アイコン）を提供します。これにより、ユーザーの入力や設定に基づいて残りの属性を自動的に埋めます。この際、ユーザーはプロンプトボックスを通じて、生成される属性に対する好みを指定できます。

#### 4.3. データ表現の切り替え

エンティティパネル内で、ユーザーは同じスキーマとデータを基に、タスクに応じて異なる表現（例：リスト、テーブル、マップビュー）に柔軟に切り替えることができます。Jellyはタスクに基づいて最も適切な表現を自動的に選択し、ユーザーはパネルの右上にあるドロップダウンメニューからいつでも切り替えられます。

### 5. エンジニアリング上の検討事項と将来の方向性

このシステムをさらに発展させるために、エンジニアが考慮すべき重要なポイントと将来的な課題は以下の通りです。

#### 5.1. 依存関係の高度なモデリング

現在のパイプラインは、エンティティや属性間のペアの関係をモデル化していますが、複雑なインタラクションを記述する上で限界があります。

• **必要な改善:** エンティティや属性がノードとなり、依存関係がより表現力の高い仕様言語で表現される**高度なグラフベースの依存関係モデリング**を探求する必要があります。これにより、ペア以外の要素間のインタラクションロジックもモデル化可能となります。

#### 5.2. 高レベルなスキーマ操作とデータ変換レイヤー

現在のスキーマ操作（追加、削除、更新）は低レベルであり、例えば「エバージョン（Eversion）」のような高レベルな変換（例：文献リストのビューを、著者を主軸とするビューに変換する）を行う場合、複雑でエラーが発生しやすい低レベル操作への変換が必要です。

• **必要な改善:** ユーザーのプロンプトを分析し、**高レベルの変換**（例：「エバージョン」操作）を直接サポートするためのスキーマ操作を拡張することが求められます。

• **データインフラ:** 伝統的なアプリケーションの固定スキーマとは異なり、Jellyの**動的データスキーマ**は、基盤となるデータベーススキーマに直接マッピングされない可能性があります。進化するスキーマの変更に対応するため、シームレスなデータ取得と適応を容易にする**データ変換レイヤー**を調査し、実装する必要があります。

#### 5.3. 外部データ統合

現在のパイプラインは主にLLM生成データに依存していますが、実用化には外部データソースやユーザー許可データとの連携が必須です。

• **必要な技術:** Retrieval-Augmented Generation (RAG) や LLM生成APIコール など、LLMを外部データと統合する最新のアプローチを活用し、信頼性の高いデータソースを技術パイプラインに組み込む必要があります。

#### 5.4. UI仕様の拡張性

Jellyの現在のUI仕様には、限られたデザインパターンしか組み込まれていません。

• **必要な改善:** ユーザーがラインチャートなどの多様な視覚化を要求した場合に対応できるよう、**包括的なUI仕様**を拡張し、多様なレイアウトや高度なインタラクションロジックを可能にする必要があります。ダッシュボードデザインパターン や、パネルの配置とプレゼンテーションを導く重要性の推論に基づいたレイアウト管理 など、先進的なビュー管理を統合することも有効です。
